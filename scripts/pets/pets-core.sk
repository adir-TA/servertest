# ============================================================
# PET CORE SYSTEM
# ============================================================
#
# Handles pet data management, slot unlocks, equip/unequip
#
# Variables:
#   {pet::owned::%uuid%::*}                  â†’ List of pet instance IDs
#   {pet::data::%uuid%::%petId%::type}       â†’ Pet type (cow, wolf, etc.)
#   {pet::data::%uuid%::%petId%::rarity}     â†’ Pet rarity
#   {pet::equipped::%uuid%::*}               â†’ List of equipped pet IDs
#   {pet::slots::%uuid%}                     â†’ Number of unlocked slots
#
# ============================================================

# ============================================================
# PET INSTANCE MANAGEMENT
# ============================================================

# Creates a new pet instance and returns its ID
function pet_create(p: player, type: text, rarity: text) :: text:
    set {_uuid} to {_p}'s uuid

    # Check pet storage limit
    set {_owned} to size of {pet::owned::%{_uuid}%::*}
    set {_maxStorage} to research_getPetStorageMax({_p})
    if {_owned} >= {_maxStorage}:
        send "&cYour pet storage is full! (%{_owned}%/%{_maxStorage}%)" to {_p}
        send "&7Salvage some pets to make room." to {_p}
        return ""

    set {_petId} to "%random uuid%"

    # Store pet data
    set {pet::data::%{_uuid}%::%{_petId}%::type} to {_type}
    set {pet::data::%{_uuid}%::%{_petId}%::rarity} to {_rarity}

    # Add to owned list
    add {_petId} to {pet::owned::%{_uuid}%::*}

    # Track discovery
    set {_isNew} to discovery_discoverPet({_p}, {_type})
    if {_isNew} is true:
        set {_loc} to {_p}'s location
        discovery_showNewPetAnimation({_p}, {_type}, {_loc})

    return {_petId}

# Deletes a pet instance (for salvaging)
function pet_delete(p: player, petId: text):
    set {_uuid} to {_p}'s uuid
    
    # Unequip if equipped
    if pet_isEquipped({_p}, {_petId}) = true:
        pet_unequip({_p}, {_petId})
    
    # Remove from owned list
    remove {_petId} from {pet::owned::%{_uuid}%::*}
    
    # Delete data
    delete {pet::data::%{_uuid}%::%{_petId}%::type}
    delete {pet::data::%{_uuid}%::%{_petId}%::rarity}
    delete {pet::data::%{_uuid}%::%{_petId}%::fusion}

# Get pet type from instance
function pet_getInstanceType(p: player, petId: text) :: text:
    return {pet::data::%{_p}'s uuid%::%{_petId}%::type} ? ""

# Get pet rarity from instance
function pet_getInstanceRarity(p: player, petId: text) :: text:
    return {pet::data::%{_p}'s uuid%::%{_petId}%::rarity} ? ""

# Get all owned pet IDs
function pet_getOwned(p: player) :: objects:
    return {pet::owned::%{_p}'s uuid%::*}

# Get owned pet count
function pet_getOwnedCount(p: player) :: number:
    return size of {pet::owned::%{_p}'s uuid%::*}


# ============================================================
# SLOT SYSTEM
# ============================================================

# Get number of unlocked slots
function pet_getUnlockedSlots(p: player) :: number:
    set {_slots} to {pet::slots::%{_p}'s uuid%} ? 0
    return {_slots}

# Get number of equipped pets
function pet_getEquippedCount(p: player) :: number:
    return size of {pet::equipped::%{_p}'s uuid%::*}

# Check if player has free equip slot
function pet_hasFreeSlot(p: player) :: boolean:
    set {_equipped} to pet_getEquippedCount({_p})
    set {_slots} to pet_getUnlockedSlots({_p})
    if {_equipped} < {_slots}:
        return true
    return false

# Check if player meets prestige requirement for a slot
function pet_meetsSlotPrestigeReq(p: player, slot: number) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_req} to pet_getSlotPrestigeReq({_slot})
    
    # Check all three archetypes
    set {_precisionPrestige} to {mining::precision::%{_uuid}%::prestige} ? 0
    set {_demolitionPrestige} to {mining::demolition::%{_uuid}%::prestige} ? 0
    set {_arcanePrestige} to {mining::arcane::%{_uuid}%::prestige} ? 0
    
    if {_precisionPrestige} < {_req}:
        return false
    if {_demolitionPrestige} < {_req}:
        return false
    if {_arcanePrestige} < {_req}:
        return false
    
    return true

# Check if player can unlock a specific slot
function pet_canUnlockSlot(p: player, slot: number) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_currentSlots} to pet_getUnlockedSlots({_p})
    
    # Already unlocked
    if {_slot} <= {_currentSlots}:
        return false
    
    # Must unlock in order
    if {_slot} != {_currentSlots} + 1:
        return false
    
    # Check prestige requirement
    if pet_meetsSlotPrestigeReq({_p}, {_slot}) = false:
        return false
    
    # Check money requirement
    set {_cost} to pet_getSlotMoneyCost({_slot})
    set {_balance} to {data::balance::%{_uuid}%} ? 0
    if {_balance} < {_cost}:
        return false
    
    return true

# Unlock the next slot
function pet_unlockSlot(p: player) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_currentSlots} to pet_getUnlockedSlots({_p})
    set {_nextSlot} to {_currentSlots} + 1
    
    if {_nextSlot} > 5:
        send "&cYou have unlocked all pet slots!" to {_p}
        return false
    
    if pet_canUnlockSlot({_p}, {_nextSlot}) = false:
        send "&cYou don't meet the requirements to unlock this slot!" to {_p}
        return false
    
    # Deduct money
    set {_cost} to pet_getSlotMoneyCost({_nextSlot})
    if {_cost} > 0:
        remove {_cost} from {data::balance::%{_uuid}%}
    
    # Unlock slot
    set {pet::slots::%{_uuid}%} to {_nextSlot}
    
    send "" to {_p}
    send "&a&lâœ“ SLOT UNLOCKED!" to {_p}
    send "&7You now have &e%{_nextSlot}% &7pet slots!" to {_p}
    if {_cost} > 0:
        send "&7Cost: &c-$%formatNum({_cost})%" to {_p}
    send "" to {_p}
    
    play sound "entity.player.levelup" with volume 1 and pitch 1.5 to {_p}
    
    # Recalculate multipliers
    multiplier_recalculate({_p})
    
    return true


# ============================================================
# EQUIP / UNEQUIP SYSTEM
# ============================================================

# Check if a pet is equipped
function pet_isEquipped(p: player, petId: text) :: boolean:
    if {pet::equipped::%{_p}'s uuid%::*} contains {_petId}:
        return true
    return false

# Get all equipped pet IDs
function pet_getEquipped(p: player) :: objects:
    return {pet::equipped::%{_p}'s uuid%::*}

# Equip a pet
function pet_equip(p: player, petId: text) :: boolean:
    set {_uuid} to {_p}'s uuid
    
    # Check if pet exists
    set {_type} to pet_getInstanceType({_p}, {_petId})
    if {_type} = "":
        send "&cPet not found!" to {_p}
        return false
    
    # Check if already equipped
    if pet_isEquipped({_p}, {_petId}) = true:
        send "&cThis pet is already equipped!" to {_p}
        return false
    
    # Check for free slot
    if pet_hasFreeSlot({_p}) = false:
        send "&cNo free pet slots! Unequip a pet first or unlock more slots." to {_p}
        return false
    
    # Equip the pet
    add {_petId} to {pet::equipped::%{_uuid}%::*}
    
    set {_rarity} to pet_getInstanceRarity({_p}, {_petId})
    set {_name} to pet_getTypeName({_type})
    set {_color} to pet_getRarityColor({_rarity})
    
    send "&aâœ“ Equipped %{_color}%%{_name}%&a!" to {_p}
    play sound "entity.armor_stand.place" with volume 0.8 and pitch 1.2 to {_p}

    # Tutorial callback
    tutorial_onPetEquip({_p})

    # Recalculate multipliers
    multiplier_recalculate({_p})

    # Refresh all follow displays (repositions arc for new count)
    petFollow_refreshAll({_p})

    return true

# Unequip a pet
function pet_unequip(p: player, petId: text) :: boolean:
    set {_uuid} to {_p}'s uuid

    # Check if equipped
    if pet_isEquipped({_p}, {_petId}) = false:
        send "&cThis pet is not equipped!" to {_p}
        return false

    # Unequip
    remove {_petId} from {pet::equipped::%{_uuid}%::*}

    set {_type} to pet_getInstanceType({_p}, {_petId})
    set {_rarity} to pet_getInstanceRarity({_p}, {_petId})
    set {_name} to pet_getTypeName({_type})
    set {_color} to pet_getRarityColor({_rarity})

    send "&câœ— Unequipped %{_color}%%{_name}%&c!" to {_p}
    play sound "entity.armor_stand.break" with volume 0.8 and pitch 0.8 to {_p}

    # Refresh all follow displays (repositions arc for new count)
    petFollow_refreshAll({_p})

    # Recalculate multipliers
    multiplier_recalculate({_p})

    return true


# ============================================================
# SALVAGE SYSTEM
# ============================================================

function pet_salvage(p: player, petId: text) :: boolean:
    set {_uuid} to {_p}'s uuid

    # Check if pet exists
    set {_type} to pet_getInstanceType({_p}, {_petId})
    if {_type} = "":
        send "&cPet not found!" to {_p}
        return false

    set {_rarity} to pet_getInstanceRarity({_p}, {_petId})
    set {_name} to pet_getTypeName({_type})
    set {_color} to pet_getRarityColor({_rarity})
    set {_baseSalvage} to pet_getSalvageValue({_rarity})
    # Apply fusion multiplier to salvage value
    set {_tokens} to petFusion_calculateSalvageValue({_p}, {_petId}, {_baseSalvage})
    set {_scrapAmount} to scrap_getSalvageAmount({_rarity})

    # Delete pet
    pet_delete({_p}, {_petId})

    # Add tokens
    add {_tokens} to {data::tokens::%{_uuid}%}

    # Add scrap
    scrap_add({_p}, {_rarity}, {_scrapAmount})

    set {_scrapName} to scrap_getName({_rarity})
    send "" to {_p}
    send "&6&lâ™» PET SALVAGED!" to {_p}
    send "&7Salvaged: %{_color}%%{_name}%" to {_p}
    send "&7Tokens: &e+%formatNum({_tokens})%" to {_p}
    send "&7Scrap: &a+%{_scrapAmount}%x %{_scrapName}%" to {_p}
    send "" to {_p}

    play sound "entity.item.break" with volume 0.8 and pitch 1 to {_p}

    return true


# ============================================================
# MULTIPLIER INTEGRATION
# ============================================================

# Returns total bonus for a specific stat from all equipped pets
function pet_getTotalBonus(p: player, stat: text) :: number:
    set {_uuid} to {_p}'s uuid
    set {_total} to 0
    
    loop {pet::equipped::%{_uuid}%::*}:
        set {_petId} to loop-value
        set {_type} to pet_getInstanceType({_p}, {_petId})
        set {_rarity} to pet_getInstanceRarity({_p}, {_petId})

        # Check if this pet boosts the requested stat
        if pet_typeHasStat({_type}, {_stat}) = true:
            set {_baseBonus} to pet_calculateBonus({_type}, {_rarity})
            # Apply fusion multiplier
            set {_finalBonus} to petFusion_calculateBonus({_p}, {_petId}, {_baseBonus})
            add {_finalBonus} to {_total}

    return {_total}


# ============================================================
# UTILITY FUNCTIONS
# ============================================================

# Get formatted pet display name with rarity color
function pet_getFormattedName(p: player, petId: text) :: text:
    set {_type} to pet_getInstanceType({_p}, {_petId})
    set {_rarity} to pet_getInstanceRarity({_p}, {_petId})
    set {_name} to pet_getTypeName({_type})
    set {_color} to pet_getRarityColor({_rarity})
    return "%{_color}%%{_name}%"

# Get formatted rarity name
function pet_getFormattedRarity(rarity: text) :: text:
    set {_color} to pet_getRarityColor({_rarity})
    set {_upper} to {_rarity}
    replace all "common" with "Common" in {_upper}
    replace all "uncommon" with "Uncommon" in {_upper}
    replace all "rare" with "Rare" in {_upper}
    replace all "epic" with "Epic" in {_upper}
    replace all "legendary" with "Legendary" in {_upper}
    return "%{_color}%%{_upper}%"

# Create item representation of a pet instance
function pet_createItem(p: player, petId: text) :: item:
    set {_type} to pet_getInstanceType({_p}, {_petId})
    set {_rarity} to pet_getInstanceRarity({_p}, {_petId})
    set {_name} to pet_getTypeName({_type})
    set {_tier} to pet_getTypeTier({_type})
    set {_fusionTier} to petFusion_getInstanceTier({_p}, {_petId})
    set {_baseBonus} to pet_calculateBonus({_type}, {_rarity})
    set {_finalBonus} to petFusion_calculateBonus({_p}, {_petId}, {_baseBonus})
    set {_bonusPercent} to {_finalBonus} * 100
    set {_color} to pet_getRarityColor({_rarity})
    set {_icon} to pet_getTypeIcon({_type})
    set {_fusionName} to petFusion_getTierName({_fusionTier})

    set {_item} to {_icon}
    set {_rarityDisplay} to pet_getFormattedRarity({_rarity})
    set {_tierFormatted} to {_tier} in strict proper case

    # Set display name based on equipped status
    if pet_isEquipped({_p}, {_petId}) = true:
        set name of {_item} to "&aâœ” %{_fusionName}%%{_color}%%{_name}%"
        # Add enchant glint but hide tooltip (1.20.5+ data components)
        set {_item} to {_item} with nbt from "{""minecraft:enchantments"":{levels:{""minecraft:unbreaking"":1},show_in_tooltip:0}}"
    else:
        set name of {_item} to "%{_fusionName}%%{_color}%%{_name}%"

    add menu_utils_getMenuItemFirstLoreLine() to {_lore::*}
    add "" to {_lore::*}
    add "&7Tier: &f%{_tierFormatted}%" to {_lore::*}
    add "&7Rarity: %{_rarityDisplay}%" to {_lore::*}

    # Show fusion tier if not normal
    if {_fusionTier} > 0:
        add "&7Fusion: %{_fusionName}%" to {_lore::*}

    add "" to {_lore::*}

    # Show stats like pickaxe enchant display
    set {_statCount} to pet_getTypeStatCount({_type})
    if {_statCount} = 1:
        set {_stat} to pet_getTypeStat({_type})
        set {_statFormatted} to pet_formatStatName({_stat})
        add "&6Bonus:" to {_lore::*}
        add " &a+%{_bonusPercent}%%% &f%{_statFormatted}%" to {_lore::*}
    else:
        add "&6Stat Bonuses:" to {_lore::*}
        loop pet_getTypeStats({_type}):
            set {_statFormatted} to pet_formatStatName(loop-value)
            add " &a+%{_bonusPercent}%%% &f%{_statFormatted}%" to {_lore::*}

    add "" to {_lore::*}

    # Salvage value preview
    set {_salvageTokens} to pet_getSalvageValue({_rarity})
    set {_salvageScrap} to scrap_getSalvageAmount({_rarity})
    set {_scrapName} to scrap_getName({_rarity})
    add "&7Salvage: &6%{_salvageTokens}% tokens &8+ &a%{_salvageScrap}%x %{_scrapName}%" to {_lore::*}
    add "" to {_lore::*}

    if pet_isEquipped({_p}, {_petId}) = true:
        add "&dâœ” Equipped" to {_lore::*}
        add "" to {_lore::*}
        add "&eClick to unequip" to {_lore::*}
    else:
        add "&eClick to equip" to {_lore::*}

    add "&c&oPress Q to salvage" to {_lore::*}
    
    set lore of {_item} to {_lore::*}
    
    # Store pet ID in NBT for click handling
    set string tag "pet;id" of custom nbt of {_item} to {_petId}
    
    return {_item}


# ============================================================
# DEBUG COMMANDS
# ============================================================

command /petgive <text> <text>:
    permission: op
    trigger:
        set {_type} to arg-1
        set {_rarity} to arg-2
        
        # Validate type
        if {-pet::type::%{_type}%::name} is not set:
            send "&cInvalid pet type: %{_type}%"
            send "&7Available: %{-pet::types::*}%"
            stop
        
        # Validate rarity
        if {-pet::rarity::%{_rarity}%::color} is not set:
            send "&cInvalid rarity: %{_rarity}%"
            send "&7Available: %{-pet::rarities::*}%"
            stop
        
        set {_petId} to pet_create(player, {_type}, {_rarity})
        set {_name} to pet_getTypeName({_type})
        set {_color} to pet_getRarityColor({_rarity})
        
        send "&aCreated pet: %{_color}%%{_name}% &7(ID: %{_petId}%)"

command /petslots:
    permission: op
    trigger:
        set {_uuid} to player's uuid
        set {_slots} to pet_getUnlockedSlots(player)
        set {_equipped} to pet_getEquippedCount(player)
        
        send ""
        send "&6&lâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        send "&e&lğŸ”“ PET SLOTS"
        send "&6&lâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        send ""
        send "&7Unlocked Slots: &e%{_slots}%/5"
        send "&7Equipped Pets: &a%{_equipped}%/%{_slots}%"
        send ""
        
        loop 5 times:
            set {_slot} to loop-number
            set {_prestigeReq} to pet_getSlotPrestigeReq({_slot})
            set {_moneyCost} to pet_getSlotMoneyCost({_slot})
            
            if {_slot} <= {_slots}:
                send "&a  âœ” Slot %{_slot}% - Unlocked" to player
            else:
                set {_metPrestige} to pet_meetsSlotPrestigeReq(player, {_slot})
                if {_metPrestige} = true:
                    set {_pStatus} to "&aâœ”"
                else:
                    set {_pStatus} to "&câœ–"
                
                send "&7  âœ– Slot %{_slot}% - Prestige %{_pStatus}% &7%{_prestigeReq}%+ | Money: &6$%formatNum({_moneyCost})%" to player
        
        send ""
        send "&6&lâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

command /petunlockslot:
    permission: op
    trigger:
        pet_unlockSlot(player)
