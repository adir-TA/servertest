# ============================================================
# PET FOLLOW SYSTEM - Client-Side Display Entities
# ============================================================
#
# Spawns fake item displays for each equipped pet that follow
# the player around. All packet-based (client-side only).
#
# Variables:
#   {-pet::follow::%uuid%::loop}            → Loop control flag
#   {-guard::pet-follow::%uuid%}            → Prevents duplicate loops
#   {-pet::follow::%uuid%::ids::%petId%}    → Display entity ID
#   {-pet::follow::%uuid%::text::%petId%}   → Nametag text entity ID
#   {-pet::follow::%uuid%::tick}            → Tick counter for bobbing
#
# ============================================================


# ============================================================
# SPAWN / DESPAWN
# ============================================================

# Spawns a single pet's follow display for a player
function petFollow_spawn(p: player, petId: text):
    set {_uuid} to {_p}'s uuid

    # Don't double-spawn
    if {-pet::follow::%{_uuid}%::ids::%{_petId}%} is set:
        stop

    set {_type} to pet_getInstanceType({_p}, {_petId})
    set {_rarity} to pet_getInstanceRarity({_p}, {_petId})
    set {_fusionTier} to petFusion_getInstanceTier({_p}, {_petId})
    if {_type} is "":
        stop

    set {_icon} to pet_getTypeIcon({_type})
    set {_name} to pet_getTypeName({_type})
    set {_color} to pet_getRarityColor({_rarity})
    set {_fusionName} to petFusion_getTierName({_fusionTier})

    # Generate entity IDs
    set {_displayId} to random integer between 100000 and 9999999
    set {_textId} to {_displayId} + 1
    set {_outerGlowId} to {_displayId} + 2

    # Store IDs
    set {-pet::follow::%{_uuid}%::ids::%{_petId}%} to {_displayId}
    set {-pet::follow::%{_uuid}%::text::%{_petId}%} to {_textId}

    # Store outer glow ID if fused
    if {_fusionTier} > 0:
        set {-pet::follow::%{_uuid}%::outer::%{_petId}%} to {_outerGlowId}

    # Get rarity glow color (inner glow)
    set {_rarityGlow} to petFollow_getGlowColor({_rarity})

    # Spawn behind player initially
    set {_loc} to {_p}'s location
    set {_yaw} to yaw of {_loc}
    set {_behindX} to x-coord of {_loc} + (1.5 * sin({_yaw}))
    set {_behindZ} to z-coord of {_loc} - (1.5 * cos({_yaw}))
    set {_spawnLoc} to location({_behindX}, y-coord of {_loc} + 0.5, {_behindZ}, world of {_loc})

    # Calculate yaw to face player
    set {_faceYaw} to petFollow_calcYaw({_behindX}, {_behindZ}, x-coord of {_loc}, z-coord of {_loc})
    set {_qy} to sin({_faceYaw} / 2)
    set {_qw} to cos({_faceYaw} / 2)

    # Spawn inner pet display (rarity glow)
    spawn fake item display at {_spawnLoc} for {_p} with id {_displayId}
    set {_m} to new metadata packet with id {_displayId}:
        display item: {_icon}
        display scale: vector(0.55, 0.55, 0.55)
        display brightness block: 15
        display teleportduration: 20
        display rotation left: 0, {_qy}, 0, {_qw}
        glowing: true
        display glow: {_rarityGlow}
    send packet {_m} to {_p}

    # Spawn outer glow if fused (fusion tier glow)
    if {_fusionTier} > 0:
        set {_fusionGlow} to petFollow_getFusionGlowColor({_fusionTier})
        set {_outerScale} to 0.55 * petFusion_getOuterGlowScale()

        spawn fake item display at {_spawnLoc} for {_p} with id {_outerGlowId}
        set {_m} to new metadata packet with id {_outerGlowId}:
            display item: {_icon}
            display scale: vector({_outerScale}, {_outerScale}, {_outerScale})
            display brightness block: 15
            display teleportduration: 20
            display rotation left: 0, {_qy}, 0, {_qw}
            glowing: true
            display glow: {_fusionGlow}
        send packet {_m} to {_p}

    # Spawn nametag
    set {_textLoc} to location({_behindX}, y-coord of {_loc} + 0.9, {_behindZ}, world of {_loc})
    spawn fake text display at {_textLoc} for {_p} with id {_textId}

    set {_m} to new metadata packet with id {_textId}:
        display text: "%{_fusionName}%%{_color}%%{_name}%"
        display billboard: center
        display brightness block: 15
        display shadow: true
        display defaultbackground: false
        display scale: vector(0.6, 0.6, 0.6)
        display teleportduration: 20
    send packet {_m} to {_p}


# Despawns a single pet's follow display
function petFollow_despawn(p: player, petId: text):
    set {_uuid} to {_p}'s uuid

    set {_displayId} to {-pet::follow::%{_uuid}%::ids::%{_petId}%}
    set {_textId} to {-pet::follow::%{_uuid}%::text::%{_petId}%}
    set {_outerGlowId} to {-pet::follow::%{_uuid}%::outer::%{_petId}%}

    if {_displayId} is set:
        remove fake entity with id {_displayId} for {_p}
        delete {-pet::follow::%{_uuid}%::ids::%{_petId}%}

    if {_textId} is set:
        remove fake entity with id {_textId} for {_p}
        delete {-pet::follow::%{_uuid}%::text::%{_petId}%}

    if {_outerGlowId} is set:
        remove fake entity with id {_outerGlowId} for {_p}
        delete {-pet::follow::%{_uuid}%::outer::%{_petId}%}


# Spawns displays for ALL currently equipped pets
function petFollow_spawnAll(p: player):
    set {_uuid} to {_p}'s uuid
    loop {pet::equipped::%{_uuid}%::*}:
        petFollow_spawn({_p}, loop-value)


# Despawns ALL pet follow displays for a player
function petFollow_despawnAll(p: player):
    set {_uuid} to {_p}'s uuid
    loop {pet::equipped::%{_uuid}%::*}:
        petFollow_despawn({_p}, loop-value)
    # Cleanup any orphaned IDs
    delete {-pet::follow::%{_uuid}%::ids::*}
    delete {-pet::follow::%{_uuid}%::text::*}
    delete {-pet::follow::%{_uuid}%::outer::*}


# Full refresh - despawn all and respawn all equipped pets
# Called on equip/unequip to update displays and arc positions
function petFollow_refreshAll(p: player):
    set {_uuid} to {_p}'s uuid

    # Remove all existing displays
    loop {-pet::follow::%{_uuid}%::ids::*}:
        remove fake entity with id loop-value for {_p}
    loop {-pet::follow::%{_uuid}%::text::*}:
        remove fake entity with id loop-value for {_p}
    loop {-pet::follow::%{_uuid}%::outer::*}:
        remove fake entity with id loop-value for {_p}
    delete {-pet::follow::%{_uuid}%::ids::*}
    delete {-pet::follow::%{_uuid}%::text::*}
    delete {-pet::follow::%{_uuid}%::outer::*}

    # Respawn for all currently equipped pets
    loop {pet::equipped::%{_uuid}%::*}:
        petFollow_spawn({_p}, loop-value)

    # Ensure loop is running
    petFollow_startLoop({_p})


# ============================================================
# FOLLOW LOOP (Guarded - same pattern as multiplier loop)
# ============================================================

function petFollow_startLoop(p: player):
    set {_uuid} to {_p}'s uuid

    # Always ensure loop flag is true so an existing loop won't stop
    # (handles quick unequip→equip before the loop wakes up)
    set {-pet::follow::%{_uuid}%::loop} to true

    # Guard - only one loop per player
    {-guard::pet-follow::%{_uuid}%} is not set
    set {-guard::pet-follow::%{_uuid}%} to a random uuid

    set {-pet::follow::%{_uuid}%::tick} to 0

    while {-pet::follow::%{_uuid}%::loop} is true:
        wait 1 second

        if {_p} is not online:
            delete {-pet::follow::%{_uuid}%::loop}
            delete {-pet::follow::%{_uuid}%::tick}
            delete {-guard::pet-follow::%{_uuid}%}
            stop

        # Check if player has any equipped pets with active displays
        set {_equippedCount} to size of {-pet::follow::%{_uuid}%::ids::*}
        if {_equippedCount} <= 0:
            delete {-pet::follow::%{_uuid}%::loop}
            delete {-pet::follow::%{_uuid}%::tick}
            delete {-guard::pet-follow::%{_uuid}%}
            stop

        add 1 to {-pet::follow::%{_uuid}%::tick}
        set {_tick} to {-pet::follow::%{_uuid}%::tick}

        # Player location
        set {_pLoc} to {_p}'s location
        set {_pYaw} to yaw of {_pLoc}
        set {_pX} to x-coord of {_pLoc}
        set {_pY} to y-coord of {_pLoc}
        set {_pZ} to z-coord of {_pLoc}
        set {_world} to world of {_pLoc}

        # Calculate positions for all pets
        set {_count} to {_equippedCount}
        set {_radius} to 1.6

        # Arc spread: wider with more pets, capped at 150 degrees
        set {_arcSpread} to min(150, 40 * {_count})

        set {_petIndex} to 0
        loop {pet::equipped::%{_uuid}%::*}:
            set {_petId} to loop-value
            set {_displayId} to {-pet::follow::%{_uuid}%::ids::%{_petId}%}
            set {_textId} to {-pet::follow::%{_uuid}%::text::%{_petId}%}
            set {_outerGlowId} to {-pet::follow::%{_uuid}%::outer::%{_petId}%}

            # Skip if not spawned
            if {_displayId} is set:
                # Calculate position in arc behind player
                if {_count} = 1:
                    set {_angle} to {_pYaw}
                else:
                    set {_halfArc} to {_arcSpread} / 2
                    set {_step} to {_arcSpread} / ({_count} - 1)
                    set {_angle} to {_pYaw} - {_halfArc} + ({_petIndex} * {_step})

                # Convert to position (behind = +sin, -cos in MC yaw convention)
                set {_targetX} to {_pX} + ({_radius} * sin({_angle}))
                set {_targetZ} to {_pZ} - ({_radius} * cos({_angle}))

                # Bobbing offset unique per pet
                set {_bobPhase} to ({_tick} * 72) + ({_petIndex} * 60)
                set {_bobY} to sin({_bobPhase}) * 0.1
                set {_targetY} to {_pY} + 0.5 + {_bobY}

                # Teleport pet display (inner glow)
                set {_targetLoc} to location({_targetX}, {_targetY}, {_targetZ}, {_world})
                send teleport packet with id {_displayId} with location {_targetLoc} to {_p}

                # Calculate facing toward player
                set {_faceYaw} to petFollow_calcYaw({_targetX}, {_targetZ}, {_pX}, {_pZ})
                set {_qy} to sin({_faceYaw} / 2)
                set {_qw} to cos({_faceYaw} / 2)

                set {_m} to new metadata packet with id {_displayId}:
                    display rotation left: 0, {_qy}, 0, {_qw}
                send packet {_m} to {_p}

                # Teleport and rotate outer glow if exists
                if {_outerGlowId} is set:
                    send teleport packet with id {_outerGlowId} with location {_targetLoc} to {_p}
                    set {_m} to new metadata packet with id {_outerGlowId}:
                        display rotation left: 0, {_qy}, 0, {_qw}
                    send packet {_m} to {_p}

                # Teleport nametag above pet
                if {_textId} is set:
                    set {_textLoc} to location({_targetX}, {_targetY} + 0.4, {_targetZ}, {_world})
                    send teleport packet with id {_textId} with location {_textLoc} to {_p}

                add 1 to {_petIndex}

    delete {-guard::pet-follow::%{_uuid}%}


# ============================================================
# HELPERS
# ============================================================

# Calculate yaw angle (degrees) from source to target position
function petFollow_calcYaw(fromX: number, fromZ: number, toX: number, toZ: number) :: number:
    set {_dx} to {_toX} - {_fromX}
    set {_dz} to {_toZ} - {_fromZ}
    return (atan2({_dx}, {_dz}) * -1) - 90


# Get glow color by rarity
function petFollow_getGlowColor(rarity: text) :: color:
    if {_rarity} = "legendary":
        return rgb(255, 170, 0)
    else if {_rarity} = "epic":
        return rgb(255, 85, 255)
    else if {_rarity} = "rare":
        return rgb(85, 85, 255)
    else if {_rarity} = "uncommon":
        return rgb(85, 255, 85)
    return rgb(170, 170, 170)

# Get fusion glow color by fusion tier (outer glow)
function petFollow_getFusionGlowColor(fusionTier: number) :: color:
    if {_fusionTier} = 1:
        # Gold - yellow/gold
        return rgb(255, 215, 0)
    else if {_fusionTier} = 2:
        # Diamond - cyan/light blue
        return rgb(0, 255, 255)
    return rgb(255, 255, 255)
