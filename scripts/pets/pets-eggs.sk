# ============================================================
# PET EGG SYSTEM
# ============================================================
#
# Handles egg purchasing, opening animation, and rolling
#
# Flow:
#   1. Right-click beacon â†’ Tier selection GUI
#   2. Click tier â†’ Amount selection (1/3/5)
#   3. Confirm â†’ Deduct money â†’ Animation â†’ Roll â†’ Results
#
# ============================================================

# ============================================================
# ALTAR INTERACTION
# ============================================================

on right click on beacon:
    cancel event
    if player has permission "pets.use":
        set {-pet::altar::%player's uuid%} to location of clicked block
        pet_openTierMenu(player)


# ============================================================
# TIER SELECTION MENU
# ============================================================

function pet_openTierMenu(p: player):
    set {_menu} to chest inventory with 3 rows named "&d&lEGG SHOP"

    # Fill with glass
    set {_filler} to black stained glass pane named "&1"
    loop 27 times:
        set slot loop-number - 1 of {_menu} to {_filler}

    # Get player progression for rarity unlocks
    set {_prestige} to progression_getPrestige({_p})
    set {_level} to progression_getLevel({_p})
    set {_uuid} to {_p}'s uuid
    set {_eggResearch} to {data::research::%{_uuid}%::pets::pet_eggs} ? 0

    # Normal Tier - Slot 11 (Requires T1 research)
    if {_eggResearch} >= 1:
        set {_normalEgg} to lime dye named "&a&lNORMAL EGG"
        set {_cost} to pet_getTierDisplayCost("normal")
        add menu_utils_getMenuItemFirstLoreLine() to {_normalLore::*}
        add "" to {_normalLore::*}
        add "&7Cost: &a%{_cost}% &7per egg" to {_normalLore::*}
        add "" to {_normalLore::*}
        add "&6Contains:" to {_normalLore::*}
        loop {-pet::tier::normal::types::*}:
            set {_name} to pet_getTypeName(loop-value)
            add " &8â€¢ &f%{_name}%" to {_normalLore::*}
        add "" to {_normalLore::*}
        add "&7Rarity Unlocks:" to {_normalLore::*}
        add " &fâ€¢ Common &aâœ“" to {_normalLore::*}
        if {_level} >= 15:
            add " &aâ€¢ Uncommon &aâœ“" to {_normalLore::*}
        else:
            add " &aâ€¢ Uncommon &8(Lv15)" to {_normalLore::*}
        if {_level} >= 25:
            add " &9â€¢ Rare &aâœ“" to {_normalLore::*}
        else:
            add " &9â€¢ Rare &8(Lv25)" to {_normalLore::*}
        if {_prestige} >= 3:
            add " &5â€¢ Epic &aâœ“" to {_normalLore::*}
        else:
            add " &5â€¢ Epic &8(P3)" to {_normalLore::*}
        if {_prestige} >= 5:
            add " &6â€¢ Legendary &aâœ“" to {_normalLore::*}
        else:
            add " &6â€¢ Legendary &8(P5)" to {_normalLore::*}
        add "" to {_normalLore::*}
        add "<#C0CF91>á´„ÊŸÉªá´„á´‹ á´›á´ sá´‡ÊŸá´‡á´„á´›" to {_normalLore::*}
        set lore of {_normalEgg} to {_normalLore::*}
        set string tag "egg;tier" of custom nbt of {_normalEgg} to "normal"
        set slot 11 of {_menu} to {_normalEgg}
    else:
        set {_locked} to gray dye named "&8&lğŸ”’ NORMAL EGG"
        delete {_lockedLore::*}
        add menu_utils_getMenuItemFirstLoreLine() to {_lockedLore::*}
        add "" to {_lockedLore::*}
        add "&7This egg tier is locked." to {_lockedLore::*}
        add "" to {_lockedLore::*}
        add "&7Research &d/research &7â†’ &dPets &7â†’ &dPet Eggs" to {_lockedLore::*}
        add "" to {_lockedLore::*}
        add "&c&lLOCKED" to {_lockedLore::*}
        set lore of {_locked} to {_lockedLore::*}
        set slot 11 of {_menu} to {_locked}

    # Ultra Tier - Slot 13 (Requires T2 research)
    if {_eggResearch} >= 2:
        set {_ultraEgg} to light blue dye named "&b&lULTRA EGG"
        set {_cost} to pet_getTierDisplayCost("ultra")
        add menu_utils_getMenuItemFirstLoreLine() to {_ultraLore::*}
        add "" to {_ultraLore::*}
        add "&7Cost: &b%{_cost}% &7per egg" to {_ultraLore::*}
        add "" to {_ultraLore::*}
        add "&6Contains:" to {_ultraLore::*}
        loop {-pet::tier::ultra::types::*}:
            set {_name} to pet_getTypeName(loop-value)
            add " &8â€¢ &f%{_name}%" to {_ultraLore::*}
        add "" to {_ultraLore::*}
        add "&7Rarity Unlocks:" to {_ultraLore::*}
        add " &fâ€¢ Common &aâœ“" to {_ultraLore::*}
        if {_level} >= 15:
            add " &aâ€¢ Uncommon &aâœ“" to {_ultraLore::*}
        else:
            add " &aâ€¢ Uncommon &8(Lv15)" to {_ultraLore::*}
        if {_level} >= 25:
            add " &9â€¢ Rare &aâœ“" to {_ultraLore::*}
        else:
            add " &9â€¢ Rare &8(Lv25)" to {_ultraLore::*}
        if {_prestige} >= 3:
            add " &5â€¢ Epic &aâœ“" to {_ultraLore::*}
        else:
            add " &5â€¢ Epic &8(P3)" to {_ultraLore::*}
        if {_prestige} >= 5:
            add " &6â€¢ Legendary &aâœ“" to {_ultraLore::*}
        else:
            add " &6â€¢ Legendary &8(P5)" to {_ultraLore::*}
        add "" to {_ultraLore::*}
        add "<#C0CF91>á´„ÊŸÉªá´„á´‹ á´›á´ sá´‡ÊŸá´‡á´„á´›" to {_ultraLore::*}
        set lore of {_ultraEgg} to {_ultraLore::*}
        set string tag "egg;tier" of custom nbt of {_ultraEgg} to "ultra"
        set slot 13 of {_menu} to {_ultraEgg}
    else:
        set {_locked} to gray dye named "&8&lğŸ”’ ULTRA EGG"
        delete {_lockedLore::*}
        add menu_utils_getMenuItemFirstLoreLine() to {_lockedLore::*}
        add "" to {_lockedLore::*}
        add "&7This egg tier is locked." to {_lockedLore::*}
        add "" to {_lockedLore::*}
        add "&7Research &d/research &7â†’ &dPets &7â†’ &dPet Eggs (T2)" to {_lockedLore::*}
        add "" to {_lockedLore::*}
        add "&c&lLOCKED" to {_lockedLore::*}
        set lore of {_locked} to {_lockedLore::*}
        set slot 13 of {_menu} to {_locked}

    # Divine Tier - Slot 15 (Requires T3 research)
    if {_eggResearch} >= 3:
        set {_divineEgg} to magenta dye named "&d&lDIVINE EGG"
        set {_cost} to pet_getTierDisplayCost("divine")
        add menu_utils_getMenuItemFirstLoreLine() to {_divineLore::*}
        add "" to {_divineLore::*}
        add "&7Cost: &d%{_cost}% &7per egg" to {_divineLore::*}
        add "" to {_divineLore::*}
        add "&6Contains:" to {_divineLore::*}
        loop {-pet::tier::divine::types::*}:
            set {_name} to pet_getTypeName(loop-value)
            add " &8â€¢ &f%{_name}%" to {_divineLore::*}
        add "" to {_divineLore::*}
        add "&7Rarity Unlocks:" to {_divineLore::*}
        add " &fâ€¢ Common &aâœ“" to {_divineLore::*}
        if {_level} >= 15:
            add " &aâ€¢ Uncommon &aâœ“" to {_divineLore::*}
        else:
            add " &aâ€¢ Uncommon &8(Lv15)" to {_divineLore::*}
        if {_level} >= 25:
            add " &9â€¢ Rare &aâœ“" to {_divineLore::*}
        else:
            add " &9â€¢ Rare &8(Lv25)" to {_divineLore::*}
        if {_prestige} >= 3:
            add " &5â€¢ Epic &aâœ“" to {_divineLore::*}
        else:
            add " &5â€¢ Epic &8(P3)" to {_divineLore::*}
        if {_prestige} >= 5:
            add " &6â€¢ Legendary &aâœ“" to {_divineLore::*}
        else:
            add " &6â€¢ Legendary &8(P5)" to {_divineLore::*}
        add "" to {_divineLore::*}
        add "<#C0CF91>á´„ÊŸÉªá´„á´‹ á´›á´ sá´‡ÊŸá´‡á´„á´›" to {_divineLore::*}
        set lore of {_divineEgg} to {_divineLore::*}
        set string tag "egg;tier" of custom nbt of {_divineEgg} to "divine"
        set slot 15 of {_menu} to {_divineEgg}
    else:
        set {_locked} to gray dye named "&8&lğŸ”’ DIVINE EGG"
        delete {_lockedLore::*}
        add menu_utils_getMenuItemFirstLoreLine() to {_lockedLore::*}
        add "" to {_lockedLore::*}
        add "&7This egg tier is locked." to {_lockedLore::*}
        add "" to {_lockedLore::*}
        add "&7Research &d/research &7â†’ &dPets &7â†’ &dPet Eggs (T3)" to {_lockedLore::*}
        add "" to {_lockedLore::*}
        add "&c&lLOCKED" to {_lockedLore::*}
        set lore of {_locked} to {_lockedLore::*}
        set slot 15 of {_menu} to {_locked}

    open {_menu} to {_p}
    set {-pet::menu::%{_p}'s uuid%} to "TIER_SELECT"


# ============================================================
# AMOUNT SELECTION MENU
# ============================================================

function pet_openAmountMenu(p: player, tier: text):
    set {_cost} to pet_getTierCost({_tier})
    set {_displayCost} to pet_getTierDisplayCost({_tier})
    set {_uuid} to {_p}'s uuid

    if {_tier} = "normal":
        set {_tierColor} to "&a"
        set {_tierName} to "NORMAL"
    else if {_tier} = "ultra":
        set {_tierColor} to "&b"
        set {_tierName} to "ULTRA"
    else:
        set {_tierColor} to "&d"
        set {_tierName} to "DIVINE"

    set {_menu} to chest inventory with 4 rows named "%{_tierColor}%&l%{_tierName}% EGGS"

    # Fill with glass
    set {_filler} to black stained glass pane named "&1"
    loop 36 times:
        set slot loop-number - 1 of {_menu} to {_filler}

    set {_balance} to {data::balance::%{_uuid}%} ? 0
    set {_currentPets} to size of {pet::owned::%{_uuid}%::*}
    set {_petStorageMax} to research_getPetStorageMax({_p})
    set {_spaceAvailable} to {_petStorageMax} - {_currentPets}
    set {_isAutoOpening} to {-pet::autoopen::%{_uuid}%} ? false

    # Storage info - Slot 4
    set {_storageItem} to chest named "&ePet Storage"
    add menu_utils_getMenuItemFirstLoreLine() to {_storageLore::*}
    add "" to {_storageLore::*}
    add "&7Storage: &8[&a%{_currentPets}%&8/&c%{_petStorageMax}%&8]" to {_storageLore::*}
    add "&7Available: &a%{_spaceAvailable}% slots" to {_storageLore::*}
    set lore of {_storageItem} to {_storageLore::*}
    set slot 4 of {_menu} to {_storageItem}

    # Open 1 - Slot 11
    set {_cost1} to {_cost}
    set {_item1} to turtle egg named "%{_tierColor}%&lOPEN 1 EGG"
    add menu_utils_getMenuItemFirstLoreLine() to {_lore1::*}
    add "" to {_lore1::*}
    add "&7Cost: %{_tierColor}%$%formatNum({_cost1})%" to {_lore1::*}
    add "" to {_lore1::*}
    if {_isAutoOpening} is true:
        add "&câœ– á´€á´œá´›á´-á´á´˜á´‡É´ ÉªÉ´ á´˜Ê€á´É¢Ê€á´‡ss" to {_lore1::*}
    else if {_spaceAvailable} < 1:
        add "&câœ– É´á´á´› á´‡É´á´á´œÉ¢Êœ sá´›á´Ê€á´€É¢á´‡!" to {_lore1::*}
    else if {_balance} >= {_cost1}:
        add "<#C0CF91>á´„ÊŸÉªá´„á´‹ á´›á´ á´˜á´œÊ€á´„Êœá´€sá´‡" to {_lore1::*}
        set string tag "egg;tier" of custom nbt of {_item1} to {_tier}
        set int tag "egg;amount" of custom nbt of {_item1} to 1
    else:
        add "&câœ– É´á´á´› á´‡É´á´á´œÉ¢Êœ á´á´É´á´‡Ê!" to {_lore1::*}
        add "&7Balance: &c$%formatNum({_balance})%" to {_lore1::*}
    set lore of {_item1} to {_lore1::*}
    set slot 11 of {_menu} to {_item1}

    # Open 3 - Slot 13
    set {_cost3} to {_cost} * 3
    set {_item3} to 3 of turtle egg named "%{_tierColor}%&lOPEN 3 EGGS"
    add menu_utils_getMenuItemFirstLoreLine() to {_lore3::*}
    add "" to {_lore3::*}
    add "&7Cost: %{_tierColor}%$%formatNum({_cost3})%" to {_lore3::*}
    add "" to {_lore3::*}
    if {_isAutoOpening} is true:
        add "&câœ– á´€á´œá´›á´-á´á´˜á´‡É´ ÉªÉ´ á´˜Ê€á´É¢Ê€á´‡ss" to {_lore3::*}
    else if {_spaceAvailable} < 3:
        add "&câœ– É´á´á´› á´‡É´á´á´œÉ¢Êœ sá´›á´Ê€á´€É¢á´‡!" to {_lore3::*}
    else if {_balance} >= {_cost3}:
        add "<#C0CF91>á´„ÊŸÉªá´„á´‹ á´›á´ á´˜á´œÊ€á´„Êœá´€sá´‡" to {_lore3::*}
        set string tag "egg;tier" of custom nbt of {_item3} to {_tier}
        set int tag "egg;amount" of custom nbt of {_item3} to 3
    else:
        add "&câœ– É´á´á´› á´‡É´á´á´œÉ¢Êœ á´á´É´á´‡Ê!" to {_lore3::*}
        add "&7Balance: &c$%formatNum({_balance})%" to {_lore3::*}
    set lore of {_item3} to {_lore3::*}
    set slot 13 of {_menu} to {_item3}

    # Open 5 - Slot 15
    set {_cost5} to {_cost} * 5
    set {_item5} to 5 of turtle egg named "%{_tierColor}%&lOPEN 5 EGGS"
    add menu_utils_getMenuItemFirstLoreLine() to {_lore5::*}
    add "" to {_lore5::*}
    add "&7Cost: %{_tierColor}%$%formatNum({_cost5})%" to {_lore5::*}
    add "" to {_lore5::*}
    if {_isAutoOpening} is true:
        add "&câœ– á´€á´œá´›á´-á´á´˜á´‡É´ ÉªÉ´ á´˜Ê€á´É¢Ê€á´‡ss" to {_lore5::*}
    else if {_spaceAvailable} < 5:
        add "&câœ– É´á´á´› á´‡É´á´á´œÉ¢Êœ sá´›á´Ê€á´€É¢á´‡!" to {_lore5::*}
    else if {_balance} >= {_cost5}:
        add "<#C0CF91>á´„ÊŸÉªá´„á´‹ á´›á´ á´˜á´œÊ€á´„Êœá´€sá´‡" to {_lore5::*}
        set string tag "egg;tier" of custom nbt of {_item5} to {_tier}
        set int tag "egg;amount" of custom nbt of {_item5} to 5
    else:
        add "&câœ– É´á´á´› á´‡É´á´á´œÉ¢Êœ á´á´É´á´‡Ê!" to {_lore5::*}
        add "&7Balance: &c$%formatNum({_balance})%" to {_lore5::*}
    set lore of {_item5} to {_lore5::*}
    set slot 15 of {_menu} to {_item5}

    # Auto-Open toggle - Slot 22
    if {_isAutoOpening} is true:
        set {_autoItem} to redstone block named "&c&lSTOP AUTO-OPEN"
        add menu_utils_getMenuItemFirstLoreLine() to {_autoLore::*}
        add "" to {_autoLore::*}
        set {_autoCount} to {-pet::autoopen::%{_uuid}%::count} ? 0
        add "&7Opened so far: &a%{_autoCount}%" to {_autoLore::*}
        add "" to {_autoLore::*}
        add "&câš  Auto-open is running!" to {_autoLore::*}
        add "" to {_autoLore::*}
        add "&cá´„ÊŸÉªá´„á´‹ á´›á´ sá´›á´á´˜" to {_autoLore::*}
        set lore of {_autoItem} to {_autoLore::*}
        set string tag "egg;action" of custom nbt of {_autoItem} to "stop_auto_open"
    else:
        set {_autoItem} to dropper named "&a&lAUTO-OPEN"
        add menu_utils_getMenuItemFirstLoreLine() to {_autoLore::*}
        add "" to {_autoLore::*}
        add "&7Automatically opens eggs" to {_autoLore::*}
        add "&7until you run out of money" to {_autoLore::*}
        add "&7or storage fills up." to {_autoLore::*}
        add "&7Filtered pets are auto-salvaged." to {_autoLore::*}
        add "" to {_autoLore::*}
        add "&7Cost per egg: %{_tierColor}%$%formatNum({_cost})%" to {_autoLore::*}
        add "&7Balance: %{_tierColor}%$%formatNum({_balance})%" to {_autoLore::*}
        add "" to {_autoLore::*}
        if {_balance} >= {_cost}:
            add "<#C0CF91>á´„ÊŸÉªá´„á´‹ á´›á´ sá´›á´€Ê€á´›" to {_autoLore::*}
            set string tag "egg;action" of custom nbt of {_autoItem} to "auto_open"
            set string tag "egg;tier" of custom nbt of {_autoItem} to {_tier}
        else:
            add "&câœ– É´á´á´› á´‡É´á´á´œÉ¢Êœ á´á´É´á´‡Ê!" to {_autoLore::*}
        set lore of {_autoItem} to {_autoLore::*}
    set slot 22 of {_menu} to {_autoItem}

    # Back button - Slot 31
    set {_back} to arrow named "&c&lBACK"
    add menu_utils_getMenuItemFirstLoreLine() to {_backLore::*}
    add "" to {_backLore::*}
    add "&7Return to tier selection" to {_backLore::*}
    add "" to {_backLore::*}
    add "<#C0CF91>á´„ÊŸÉªá´„á´‹ á´›á´ É¢á´ Ê™á´€á´„á´‹" to {_backLore::*}
    set lore of {_back} to {_backLore::*}
    set string tag "egg;action" of custom nbt of {_back} to "back"
    set slot 31 of {_menu} to {_back}

    open {_menu} to {_p}
    set {-pet::menu::%{_uuid}%} to "AMOUNT_SELECT"


# ============================================================
# MENU CLICK HANDLERS
# ============================================================

on inventory click:
    set {_menu} to {-pet::menu::%player's uuid%}
    
    if {_menu} = "TIER_SELECT":
        cancel event
        
        set {_nbt} to custom nbt of clicked slot
        set {_tier} to string tag "egg;tier" of {_nbt}
        
        if {_tier} is set:
            play sound "ui.button.click" with volume 0.5 and pitch 1 to player
            pet_openAmountMenu(player, {_tier})
    
    else if {_menu} = "AMOUNT_SELECT":
        cancel event

        set {_nbt} to custom nbt of clicked slot

        # Check for actions
        set {_action} to string tag "egg;action" of {_nbt}
        if {_action} = "back":
            play sound "ui.button.click" with volume 0.5 and pitch 1 to player
            pet_openTierMenu(player)
            stop

        if {_action} = "auto_open":
            set {_tier} to string tag "egg;tier" of {_nbt}
            if {_tier} is set:
                play sound "ui.button.click" with volume 0.5 and pitch 1 to player
                close inventory of player
                pet_autoOpen(player, {_tier})
            stop

        if {_action} = "stop_auto_open":
            play sound "ui.button.click" with volume 0.5 and pitch 1 to player
            set {_tier} to {-pet::autoopen::%player's uuid%::tier} ? "normal"
            pet_stopAutoOpen(player)
            pet_openAmountMenu(player, {_tier})
            stop

        # Check for purchase
        set {_tier} to string tag "egg;tier" of {_nbt}
        set {_amount} to int tag "egg;amount" of {_nbt}

        if {_tier} is set:
            if {_amount} is set:
                close inventory of player
                pet_purchaseAndOpen(player, {_tier}, {_amount})

on inventory close:
    if {-pet::menu::%player's uuid%} = "TIER_SELECT":
        delete {-pet::menu::%player's uuid%}
    else if {-pet::menu::%player's uuid%} = "AMOUNT_SELECT":
        delete {-pet::menu::%player's uuid%}
        pet_stopAutoOpen(player)


# ============================================================
# AUTO-OPEN
# ============================================================

function pet_autoOpen(p: player, tier: text):
    set {_uuid} to {_p}'s uuid

    # Prevent duplicate
    if {-pet::autoopen::%{_uuid}%} is set:
        send "&c&l! &7Auto-open is already running!" to {_p}
        stop

    set {-pet::autoopen::%{_uuid}%} to true
    set {-pet::autoopen::%{_uuid}%::tier} to {_tier}
    set {-pet::autoopen::%{_uuid}%::count} to 0
    set {-pet::autoopen::%{_uuid}%::tokens} to 0
    set {_cost} to pet_getTierCost({_tier})

    send "&a&l! &7Auto-open started! Re-open the egg menu to stop." to {_p}
    play sound "ui.button.click" with volume 0.5 and pitch 1 to {_p}

    while {-pet::autoopen::%{_uuid}%} is true:
        # Check player online
        if {_p} is not online:
            pet_stopAutoOpen({_p})
            stop

        # Check money
        set {_balance} to {data::balance::%{_uuid}%} ? 0
        if {_balance} < {_cost}:
            send "&c&l! &7Not enough money! Auto-open stopped." to {_p}
            play sound "entity.villager.no" with volume 0.5 and pitch 1 to {_p}
            pet_stopAutoOpen({_p})
            stop

        # Determine batch size
        set {_maxAffordable} to floor({_balance} / {_cost})
        set {_batch} to {_maxAffordable}
        if {_batch} > 5:
            set {_batch} to 5

        # Deduct money
        set {_totalCost} to {_cost} * {_batch}
        remove {_totalCost} from {data::balance::%{_uuid}%}

        # Roll and create pets (with auto-salvage filtering)
        set {_batchTokens} to 0
        set {_storageBlocked} to false
        loop {_batch} times:
            set {_rarity} to pet_rollRarity({_tier})
            set {_rarity} to progression_capPetRarity({_p}, {_rarity})
            set {_type} to pet_rollType({_tier})

            # Check auto-salvage filter
            if filter_shouldSalvagePet({_p}, {_type}, {_rarity}) is true:
                set {_salvageValue} to pet_getSalvageValue({_rarity})
                mining_giveTokens({_p}, {_salvageValue})
                add {_salvageValue} to {_batchTokens}
                set {_scrapAmt} to scrap_getSalvageAmount({_rarity})
                scrap_add({_p}, {_rarity}, {_scrapAmt})
                discovery_discoverPet({_p}, {_type})
            else:
                # Check storage space before creating
                set {_currentPets} to size of {pet::owned::%{_uuid}%::*}
                set {_petStorageMax} to research_getPetStorageMax({_p})
                if {_currentPets} < {_petStorageMax}:
                    pet_create({_p}, {_type}, {_rarity})
                else:
                    # Storage full - salvage as overflow
                    set {_salvageValue} to pet_getSalvageValue({_rarity})
                    mining_giveTokens({_p}, {_salvageValue})
                    add {_salvageValue} to {_batchTokens}
                    set {_scrapAmt} to scrap_getSalvageAmount({_rarity})
                    scrap_add({_p}, {_rarity}, {_scrapAmt})
                    discovery_discoverPet({_p}, {_type})
                    set {_storageBlocked} to true

        add {_batchTokens} to {-pet::autoopen::%{_uuid}%::tokens}
        add {_batch} to {-pet::autoopen::%{_uuid}%::count}
        set {_total} to {-pet::autoopen::%{_uuid}%::count}

        # Show progress via action bar
        set {_newBalance} to {data::balance::%{_uuid}%} ? 0
        if {_batchTokens} > 0:
            send action bar "&aAuto-Opening... &f%{_total}% eggs &7| &f$%formatNum({_newBalance})% left &7| &6+%{_batchTokens}% tokens" to {_p}
        else:
            send action bar "&aAuto-Opening... &f%{_total}% eggs &7| &f$%formatNum({_newBalance})% left" to {_p}
        play sound "entity.item.pickup" with volume 0.3 and pitch 1.2 to {_p}

        # Stop if storage full and a non-filtered item couldn't be stored
        if {_storageBlocked} is true:
            send "&c&l! &7Pet storage full! Auto-open stopped." to {_p}
            play sound "entity.villager.no" with volume 0.5 and pitch 1 to {_p}
            pet_stopAutoOpen({_p})
            stop

        wait 3 seconds

    # Loop ended (cancelled by player)
    set {_total} to {-pet::autoopen::%{_uuid}%::count} ? 0
    set {_totalTokens} to {-pet::autoopen::%{_uuid}%::tokens} ? 0
    if {_total} > 0:
        send "" to {_p}
        send "&a&l! &7Auto-open complete: &f%{_total}% &7eggs opened." to {_p}
        if {_totalTokens} > 0:
            send "&7Auto-salvaged: &6+%{_totalTokens}% tokens" to {_p}
        send "" to {_p}
    pet_stopAutoOpen({_p})

function pet_stopAutoOpen(p: player):
    set {_uuid} to {_p}'s uuid
    delete {-pet::autoopen::%{_uuid}%}
    delete {-pet::autoopen::%{_uuid}%::tier}
    delete {-pet::autoopen::%{_uuid}%::count}
    delete {-pet::autoopen::%{_uuid}%::tokens}


# ============================================================
# PURCHASE AND OPENING
# ============================================================

function pet_purchaseAndOpen(p: player, tier: text, amount: number):
    set {_uuid} to {_p}'s uuid
    set {_costPer} to pet_getTierCost({_tier})
    set {_totalCost} to {_costPer} * {_amount}
    set {_balance} to {data::balance::%{_uuid}%} ? 0
    
    # Check pet storage space first
    set {_currentPets} to size of {pet::owned::%{_uuid}%::*}
    set {_petStorageMax} to research_getPetStorageMax({_p})
    set {_spaceAvailable} to {_petStorageMax} - {_currentPets}
    if {_spaceAvailable} < {_amount}:
        send "&cNot enough pet storage space!" to {_p}
        send "&7You have &e%{_currentPets}%/%{_petStorageMax}% &7pets. Need space for &e%{_amount}%&7." to {_p}
        play sound "entity.villager.no" with volume 0.8 and pitch 1 to {_p}
        stop
    
    # Final balance check
    if {_balance} < {_totalCost}:
        send "&cNot enough money! Need &6$%formatNum({_totalCost})%" to {_p}
        play sound "entity.villager.no" with volume 0.8 and pitch 1 to {_p}
        stop
    
    # Deduct money
    remove {_totalCost} from {data::balance::%{_uuid}%}
    
    # Get tier color
    if {_tier} = "normal":
        set {_tierColor} to "&a"
    else if {_tier} = "ultra":
        set {_tierColor} to "&b"
    else:
        set {_tierColor} to "&d"
    
    send "" to {_p}
    send "%{_tierColor}%Opening %{_amount}% eggs..." to {_p}
    send "&7Cost: &4$&c%formatNum({_totalCost})%" to {_p}
    send "" to {_p}
    
    # Play opening animation and roll pets
    set {_altarLoc} to {-pet::altar::%{_uuid}%}
    delete {-pet::altar::%{_uuid}%}
    pet_playOpeningSequence({_p}, {_tier}, {_amount}, {_altarLoc})


# ============================================================
# OPENING ANIMATION SEQUENCE (Display Entities) - ALL AT ONCE
# ============================================================

function pet_playOpeningSequence(p: player, tier: text, amount: number, altarLoc: location):
    # Prevent duplicate opening
    if {-pet::opening::%{_p}'s uuid%} is set:
        send "&cAlready opening eggs!" to {_p}
        stop
    
    set {-pet::opening::%{_p}'s uuid%} to true

    # Use altar location (beacon) as spawn point - centered on block
    set {_blockLoc} to location(floor(x-coord of {_altarLoc}), floor(y-coord of {_altarLoc}), floor(z-coord of {_altarLoc}), world of {_altarLoc})
    set {_centerX} to floor(x-coord of {_altarLoc}) + 0.5
    set {_centerY} to floor(y-coord of {_altarLoc}) + 1.2
    set {_centerZ} to floor(z-coord of {_altarLoc}) + 0.5
    set {_loc} to location({_centerX}, {_centerY}, {_centerZ}, world of {_altarLoc})

    # Calculate direction to face player - SNAP to 4 cardinal directions (no diagonals)
    set {_playerX} to x-coord of {_p}'s location
    set {_playerZ} to z-coord of {_p}'s location
    set {_dirX} to {_playerX} - {_centerX}
    set {_dirZ} to {_playerZ} - {_centerZ}

    # Snap to nearest cardinal direction (N/S/E/W)
    if abs({_dirX}) >= abs({_dirZ}):
        # East or West
        if {_dirX} >= 0:
            set {_dirX} to 1
        else:
            set {_dirX} to -1
        set {_dirZ} to 0
    else:
        # North or South
        if {_dirZ} >= 0:
            set {_dirZ} to 1
        else:
            set {_dirZ} to -1
        set {_dirX} to 0

    # Perpendicular direction (rotate 90 degrees) for lineup
    set {_perpX} to 0 - {_dirZ}
    set {_perpZ} to {_dirX}
    
    # Hide the beacon block (show as air)
    make {_p} see block at {_blockLoc} as air
    
    # Get tier color for glow
    if {_tier} = "normal":
        set {_glowColor} to rgb(85, 255, 85)
        set {_eggItem} to turtle egg
    else if {_tier} = "ultra":
        set {_glowColor} to rgb(85, 255, 255)
        set {_eggItem} to turtle egg
    else:
        set {_glowColor} to rgb(255, 85, 255)
        set {_eggItem} to dragon egg
    
    # Base ID for all entities
    set {_baseId} to random integer between 100000 and 9999999
    
    # Check if player has enough storage space
    set {_currentPets} to size of {pet::owned::%{_p}'s uuid%::*}
    set {_spaceNeeded} to {_amount}
    set {_petStorageMax} to research_getPetStorageMax({_p})
    set {_spaceAvailable} to {_petStorageMax} - {_currentPets}

    if {_spaceAvailable} < {_spaceNeeded}:
        send "&cNot enough pet storage space!" to {_p}
        send "&7You have &e%{_currentPets}%/%{_petStorageMax}% &7pets. Need space for &e%{_spaceNeeded}%&7." to {_p}
        send "&7Salvage some pets first!" to {_p}
        make {_p} see block at {_blockLoc} as beacon
        delete {-pet::opening::%{_p}'s uuid%}
        stop
    
    # Roll all pets and setup data
    set {_totalSalvageTokens} to 0
    set {_totalSalvageScrap::common} to 0
    set {_totalSalvageScrap::uncommon} to 0
    set {_totalSalvageScrap::rare} to 0
    set {_totalSalvageScrap::epic} to 0
    set {_totalSalvageScrap::legendary} to 0
    set {_salvageCount} to 0
    set {_keptCount} to 0
    loop {_amount} times:
        set {_i} to loop-number
        set {_rarity} to pet_rollRarity({_tier})
        # Cap rarity based on player progression
        set {_rarity} to progression_capPetRarity({_p}, {_rarity})
        set {_type} to pet_rollType({_tier})

        # Check if this pet should be auto-salvaged
        set {_shouldSalvage} to filter_shouldSalvagePet({_p}, {_type}, {_rarity})
        set {_results::%{_i}%::salvaged} to {_shouldSalvage}

        # Check if this is a NEW discovery (before creating)
        set {_isNewDiscovery} to discovery_hasPetDiscovered({_p}, {_type})
        if {_isNewDiscovery} is false:
            set {_results::%{_i}%::isNew} to true
        else:
            set {_results::%{_i}%::isNew} to false

        if {_shouldSalvage} is true:
            # Auto-salvage: don't create pet, track tokens and scrap
            set {_salvageValue} to pet_getSalvageValue({_rarity})
            add {_salvageValue} to {_totalSalvageTokens}
            set {_scrapAmt} to scrap_getSalvageAmount({_rarity})
            add {_scrapAmt} to {_totalSalvageScrap::%{_rarity}%}
            add 1 to {_salvageCount}
            set {_results::%{_i}%::salvageValue} to {_salvageValue}
            # Still track discovery even if salvaged
            discovery_discoverPet({_p}, {_type})
        else:
            # Keep: create the pet normally (this also handles discovery)
            set {_petId} to pet_create({_p}, {_type}, {_rarity})
            set {_results::%{_i}%::petId} to {_petId}
            add 1 to {_keptCount}

        set {_results::%{_i}%::type} to {_type}
        set {_results::%{_i}%::rarity} to {_rarity}

        # Calculate offset position - perpendicular to player view
        set {_offsetMult} to ({_i} - (({_amount} + 1) / 2)) * 1.0
        set {_eggX::%{_i}%} to {_centerX} + ({_perpX} * {_offsetMult})
        set {_eggY::%{_i}%} to {_centerY}
        set {_eggZ::%{_i}%} to {_centerZ} + ({_perpZ} * {_offsetMult})

        # Assign entity IDs
        set {_eggId::%{_i}%} to {_baseId} + ({_i} * 10)
        set {_petId::%{_i}%} to {_baseId} + ({_i} * 10) + 1
        set {_textId::%{_i}%} to {_baseId} + ({_i} * 10) + 2

        # Get pet data - use barrier for auto-salvaged pets
        if {_shouldSalvage} is true:
            set {_petIcon::%{_i}%} to barrier
        else:
            set {_petIcon::%{_i}%} to pet_getTypeIcon({_type})
        set {_petName::%{_i}%} to pet_getTypeName({_type})
        set {_rarityColor::%{_i}%} to pet_getRarityColor({_rarity})

        # Get rarity glow color - grey for salvaged
        if {_shouldSalvage} is true:
            set {_petGlow::%{_i}%} to rgb(100, 100, 100)
        else if {_rarity} = "legendary":
            set {_petGlow::%{_i}%} to rgb(255, 170, 0)
        else if {_rarity} = "epic":
            set {_petGlow::%{_i}%} to rgb(255, 85, 255)
        else if {_rarity} = "rare":
            set {_petGlow::%{_i}%} to rgb(85, 85, 255)
        else if {_rarity} = "uncommon":
            set {_petGlow::%{_i}%} to rgb(85, 255, 85)
        else:
            set {_petGlow::%{_i}%} to rgb(170, 170, 170)

    # Give salvage tokens if any
    if {_totalSalvageTokens} > 0:
        mining_giveTokens({_p}, {_totalSalvageTokens})

    # Give salvage scrap per rarity
    loop "common", "uncommon", "rare", "epic" and "legendary":
        set {_scrapVal} to {_totalSalvageScrap::%loop-value%} ? 0
        if {_scrapVal} > 0:
            scrap_add({_p}, loop-value, {_scrapVal})

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SKIP ANIMATION (if option enabled)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if options_getBool({_p}, "skip_egg_anim", false) is true:
        make {_p} see block at {_blockLoc} as beacon
        play sound "entity.item.pickup" with volume 0.6 and pitch 1.2 to {_p}
        send "" to {_p}
        if {_keptCount} > 0:
            send "&aReceived %{_keptCount}% pets!" to {_p}
            loop {_amount} times:
                set {_i} to loop-number
                if {_results::%{_i}%::salvaged} is not true:
                    set {_typeName} to pet_getTypeName({_results::%{_i}%::type})
                    set {_rarColor} to pet_getRarityColor({_results::%{_i}%::rarity})
                    set {_rarName} to {_results::%{_i}%::rarity}
                    if {_results::%{_i}%::isNew} is true:
                        send " &b[NEW] %{_rarColor}%%{_rarName}% %{_typeName}%" to {_p}
                    else:
                        send " %{_rarColor}%%{_rarName}% %{_typeName}%" to {_p}
            send "&7Use &e/pets &7to view and equip them!" to {_p}
        if {_salvageCount} > 0:
            send "&8Auto-salvaged %{_salvageCount}% pets: &6+%{_totalSalvageTokens}% tokens" to {_p}
            # Show scrap from auto-salvage
            loop "common", "uncommon", "rare", "epic" and "legendary":
                set {_scrapVal} to {_totalSalvageScrap::%loop-value%} ? 0
                if {_scrapVal} > 0:
                    set {_scrapName} to scrap_getName(loop-value)
                    send "&8 + &a%{_scrapVal}%x %{_scrapName}%" to {_p}
        send "" to {_p}
        delete {-pet::opening::%{_p}'s uuid%}
        stop

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 1: All eggs appear and grow
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    loop {_amount} times:
        set {_i} to loop-number
        set {_spawnPos} to location({_eggX::%{_i}%}, {_eggY::%{_i}%}, {_eggZ::%{_i}%}, world of {_loc})
        
        spawn fake item display at {_spawnPos} for {_p} with id {_eggId::%{_i}%}
        
        set {_m} to new metadata packet with id {_eggId::%{_i}%}:
            display item: {_eggItem}
            display scale: vector(0.01, 0.01, 0.01)
            display billboard: center
            display brightness block: 15
            display teleportduration: 2
            display transformation: 3
            display interpolation: 0
            glowing: true
            display glow: {_glowColor}
        send packet {_m} to {_p}
    
    play sound "entity.item.pickup" with volume 0.7 and pitch 0.6 to {_p}
    
    wait 1 tick
    
    # Grow all eggs
    loop {_amount} times:
        set {_i} to loop-number
        set {_m} to new metadata packet with id {_eggId::%{_i}%}:
            display scale: vector(0.8, 0.8, 0.8)
            display transformation: 4
            display interpolation: 0
        send packet {_m} to {_p}
    
    wait 4 ticks
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 2: All eggs wobble together
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    loop 3 times:
        set {_wobble} to loop-number
        
        # Tilt all left
        loop {_amount} times:
            set {_i} to loop-number-2
            set {_m} to new metadata packet with id {_eggId::%{_i}%}:
                display rotation left: 0, 0, 0.15, 0.99
                display transformation: 2
                display interpolation: 0
            send packet {_m} to {_p}
        
        play sound "block.wood.hit" with volume 0.5 and pitch 1.2 + ({_wobble} * 0.1) to {_p}
        
        wait 3 ticks
        
        # Tilt all right
        loop {_amount} times:
            set {_i} to loop-number-2
            set {_m} to new metadata packet with id {_eggId::%{_i}%}:
                display rotation left: 0, 0, -0.15, 0.99
                display transformation: 2
                display interpolation: 0
            send packet {_m} to {_p}
        
        wait 3 ticks
        
        # Center all
        loop {_amount} times:
            set {_i} to loop-number-2
            set {_m} to new metadata packet with id {_eggId::%{_i}%}:
                display rotation left: 0, 0, 0, 1
                display transformation: 2
                display interpolation: 0
            send packet {_m} to {_p}
        
        wait 2 ticks
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 3: All eggs shake and explode
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    # Quick shake all
    loop 4 times:
        loop {_amount} times:
            set {_i} to loop-number-2
            set {_shakeX} to random number between -0.08 and 0.08
            set {_shakeLoc} to location({_eggX::%{_i}%} + {_shakeX}, {_eggY::%{_i}%}, {_eggZ::%{_i}%}, world of {_loc})
            send teleport packet with id {_eggId::%{_i}%} with location {_shakeLoc} to {_p}
        wait 1 tick
    
    # Expand all before pop
    loop {_amount} times:
        set {_i} to loop-number
        set {_m} to new metadata packet with id {_eggId::%{_i}%}:
            display scale: vector(1.2, 1.2, 1.2)
            display transformation: 2
            display interpolation: 0
        send packet {_m} to {_p}
    
    wait 2 ticks
    
    # Pop sound - use best rarity sound
    set {_bestRarity} to "common"
    loop {_amount} times:
        set {_i} to loop-number
        set {_r} to {_results::%{_i}%::rarity}
        if {_r} = "legendary":
            set {_bestRarity} to "legendary"
        else if {_r} = "epic":
            if {_bestRarity} != "legendary":
                set {_bestRarity} to "epic"
    
    if {_bestRarity} = "legendary":
        play sound "ui.toast.challenge_complete" with volume 1.2 and pitch 1.2 to {_p}
    else if {_bestRarity} = "epic":
        play sound "entity.player.levelup" with volume 1 and pitch 1.5 to {_p}
    else:
        play sound "entity.chicken.egg" with volume 0.8 and pitch 0.8 to {_p}
    
    # Shrink and remove all eggs
    loop {_amount} times:
        set {_i} to loop-number
        set {_m} to new metadata packet with id {_eggId::%{_i}%}:
            display scale: vector(0.01, 0.01, 0.01)
            display transformation: 1
            display interpolation: 0
        send packet {_m} to {_p}
    
    wait 1 tick
    
    loop {_amount} times:
        set {_i} to loop-number
        remove fake entity with id {_eggId::%{_i}%} for {_p}
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 4: All pets reveal together
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    loop {_amount} times:
        set {_i} to loop-number
        set {_revealLoc} to location({_eggX::%{_i}%}, {_eggY::%{_i}%}, {_eggZ::%{_i}%}, world of {_loc})
        
        spawn fake item display at {_revealLoc} for {_p} with id {_petId::%{_i}%}
        
        set {_m} to new metadata packet with id {_petId::%{_i}%}:
            display item: {_petIcon::%{_i}%}
            display scale: vector(0.01, 0.01, 0.01)
            display billboard: center
            display brightness block: 15
            display teleportduration: 2
            display transformation: 3
            display interpolation: 0
            glowing: true
            display glow: {_petGlow::%{_i}%}
        send packet {_m} to {_p}
    
    wait 1 tick
    
    # Pop out and grow all
    loop {_amount} times:
        set {_i} to loop-number
        set {_m} to new metadata packet with id {_petId::%{_i}%}:
            display scale: vector(0.6, 0.6, 0.6)
            display transformation: 4
            display interpolation: 0
        send packet {_m} to {_p}
        
        set {_riseLoc} to location({_eggX::%{_i}%}, {_eggY::%{_i}%} + 0.8, {_eggZ::%{_i}%}, world of {_loc})
        send teleport packet with id {_petId::%{_i}%} with location {_riseLoc} to {_p}
    
    wait 3 ticks
    
    # Spin animation all together (12 frames)
    loop 12 times:
        set {_frame} to loop-number - 1
        set {_floatOffset} to sin({_frame} * 30) * 0.15
        set {_angle} to {_frame} * 30
        set {_qy} to sin({_angle} / 2)
        set {_qw} to cos({_angle} / 2)
        
        loop {_amount} times:
            set {_i} to loop-number-2
            set {_spinLoc} to location({_eggX::%{_i}%}, {_eggY::%{_i}%} + 0.8 + {_floatOffset}, {_eggZ::%{_i}%}, world of {_loc})
            send teleport packet with id {_petId::%{_i}%} with location {_spinLoc} to {_p}
            
            set {_m} to new metadata packet with id {_petId::%{_i}%}:
                display rotation left: 0, {_qy}, 0, {_qw}
                display transformation: 2
                display interpolation: 0
            send packet {_m} to {_p}
        
        wait 2 ticks
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 5: Show all result texts (fan/arc layout)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    loop {_amount} times:
        set {_i} to loop-number
        set {_type} to {_results::%{_i}%::type}
        set {_rarity} to {_results::%{_i}%::rarity}
        
        # Calculate arc position - center highest, edges lower (inverted arc)
        set {_centerIndex} to ({_amount} + 1) / 2
        set {_diff} to {_i} - {_centerIndex}
        if {_diff} < 0:
            set {_distFromCenter} to 0 - {_diff}
        else:
            set {_distFromCenter} to {_diff}
        
        # Arc height - center is highest, outer ones go lower
        set {_arcHeight} to 2.0 - ({_distFromCenter} * 0.15)
        
        # Arc spread - tighter spread
        set {_spreadMult} to 1 + ({_distFromCenter} * 0.4)
        set {_offsetMult} to {_diff} * {_spreadMult} * 1.1
        
        set {_textX} to {_centerX} + ({_perpX} * {_offsetMult})
        set {_textZ} to {_centerZ} + ({_perpZ} * {_offsetMult})
        set {_textLoc} to location({_textX}, {_eggY::%{_i}%} + {_arcHeight}, {_textZ}, world of {_loc})
        
        # Store for later animation
        set {_textArcHeight::%{_i}%} to {_arcHeight}
        set {_textX::%{_i}%} to {_textX}
        set {_textZ::%{_i}%} to {_textZ}
        
        spawn fake text display at {_textLoc} for {_p} with id {_textId::%{_i}%}
        
        set {_bonus} to pet_calculateBonus({_type}, {_rarity}) * 100
        
        # Build stats text - condensed format with proper formatting
        set {_statCount} to pet_getTypeStatCount({_type})
        if {_statCount} = 1:
            set {_stat} to pet_getTypeStat({_type})
            set {_statFormatted} to pet_formatStatName({_stat})
            set {_statsText} to "&a+%{_bonus}%%% %{_statFormatted}%"
        else:
            # Multiple stats - show on one line
            set {_statsList} to ""
            loop pet_getTypeStats({_type}):
                set {_stat} to loop-value-2
                set {_statFormatted} to pet_formatStatName({_stat})
                if {_statsList} != "":
                    set {_statsList} to "%{_statsList}%, %{_statFormatted}%"
                else:
                    set {_statsList} to {_statFormatted}
            set {_statsText} to "&a+%{_bonus}%%% &7%{_statsList}%"
        
        # Build beautiful display text with stats (matching treasure style)
        # Check if this pet was auto-salvaged
        set {_wasSalvaged} to {_results::%{_i}%::salvaged}
        set {_isNew} to {_results::%{_i}%::isNew}

        # NEW! prefix for first-time discoveries
        if {_isNew} is true:
            set {_newPrefix} to "&b&lNEW!%nl%"
        else:
            set {_newPrefix} to ""

        if {_wasSalvaged} is true:
            set {_salvageValue} to {_results::%{_i}%::salvageValue}
            set {_displayText} to "%{_newPrefix}%&8&l[RECYCLED]%nl%%{_rarityColor::%{_i}%}%%{_petName::%{_i}%}%%nl%&6+%{_salvageValue}% tokens"
        else if {_rarity} = "legendary":
            set {_displayText} to "%{_newPrefix}%&6&lâœ¦ LEGENDARY âœ¦%nl%%{_rarityColor::%{_i}%}%&l%{_petName::%{_i}%}%%nl%&8â”â”â”â”â”â”â”â”â”â”â”â”%nl%%{_statsText}%"
        else if {_rarity} = "epic":
            set {_displayText} to "%{_newPrefix}%&d&lâ˜… EPIC â˜…%nl%%{_rarityColor::%{_i}%}%%{_petName::%{_i}%}%%nl%&8â”€â”€â”€â”€â”€â”€â”€â”€â”€%nl%%{_statsText}%"
        else if {_rarity} = "rare":
            set {_displayText} to "%{_newPrefix}%&9âœ§ Rare%nl%%{_rarityColor::%{_i}%}%%{_petName::%{_i}%}%%nl%%{_statsText}%"
        else if {_rarity} = "uncommon":
            set {_displayText} to "%{_newPrefix}%&aâ—‹ Uncommon%nl%%{_rarityColor::%{_i}%}%%{_petName::%{_i}%}%%nl%%{_statsText}%"
        else:
            set {_displayText} to "%{_newPrefix}%&7â€¢ Common%nl%%{_rarityColor::%{_i}%}%%{_petName::%{_i}%}%%nl%%{_statsText}%"
        
        set {_m} to new metadata packet with id {_textId::%{_i}%}:
            display text: {_displayText}
            display billboard: center
            display brightness block: 15
            display shadow: true
            display defaultbackground: false
            display scale: vector(0.01, 0.01, 0.01)
            display teleportduration: 2
        send packet {_m} to {_p}
    
    wait 1 tick
    
    # Scale up all texts and float up (maintaining arc)
    loop {_amount} times:
        set {_i} to loop-number
        set {_m} to new metadata packet with id {_textId::%{_i}%}:
            display scale: vector(0.75, 0.75, 0.75)
            display transformation: 3
            display interpolation: 0
        send packet {_m} to {_p}
        
        set {_textEndLoc} to location({_textX::%{_i}%}, {_eggY::%{_i}%} + {_textArcHeight::%{_i}%} + 0.4, {_textZ::%{_i}%}, world of {_loc})
        send teleport packet with id {_textId::%{_i}%} with location {_textEndLoc} to {_p}
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 6: All pets fly to player
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    wait 25 ticks
    
    # Shrink all texts
    loop {_amount} times:
        set {_i} to loop-number
        set {_m} to new metadata packet with id {_textId::%{_i}%}:
            display scale: vector(0.01, 0.01, 0.01)
            display transformation: 3
            display interpolation: 0
        send packet {_m} to {_p}
    
    # All pets fly to player
    set {_playerLoc} to location of {_p}
    set {_playerLoc} to {_playerLoc} ~ vector(0, 1.2, 0)
    
    loop {_amount} times:
        set {_i} to loop-number
        set {_m} to new metadata packet with id {_petId::%{_i}%}:
            display scale: vector(0.3, 0.3, 0.3)
            display teleportduration: 4
            display transformation: 3
            display interpolation: 0
        send packet {_m} to {_p}
        
        send teleport packet with id {_petId::%{_i}%} with location {_playerLoc} to {_p}
    
    wait 4 ticks
    
    # Shrink and collect all
    loop {_amount} times:
        set {_i} to loop-number
        set {_m} to new metadata packet with id {_petId::%{_i}%}:
            display scale: vector(0.01, 0.01, 0.01)
            display transformation: 2
            display interpolation: 0
        send packet {_m} to {_p}
    
    play sound "entity.item.pickup" with volume 0.6 and pitch 1.2 to {_p}
    
    wait 3 ticks
    
    # Cleanup all
    loop {_amount} times:
        set {_i} to loop-number
        remove fake entity with id {_petId::%{_i}%} for {_p}
        remove fake entity with id {_textId::%{_i}%} for {_p}
    
    # Restore the beacon block
    make {_p} see block at {_blockLoc} as beacon
    
    # Summary
    send "" to {_p}
    if {_keptCount} > 0:
        send "&aReceived %{_keptCount}% pets!" to {_p}
        send "&7Use &e/pets &7to view and equip them!" to {_p}
    if {_salvageCount} > 0:
        send "&8Auto-salvaged %{_salvageCount}% pets: &6+%{_totalSalvageTokens}% tokens" to {_p}
        # Show scrap from auto-salvage
        loop "common", "uncommon", "rare", "epic" and "legendary":
            set {_scrapVal} to {_totalSalvageScrap::%loop-value%} ? 0
            if {_scrapVal} > 0:
                set {_scrapName} to scrap_getName(loop-value)
                send "&8 + &a%{_scrapVal}%x %{_scrapName}%" to {_p}
    send "" to {_p}

    delete {-pet::opening::%{_p}'s uuid%}


# ============================================================
# ROLLING FUNCTIONS
# ============================================================

# Roll rarity based on tier weights
function pet_rollRarity(tier: text) :: text:
    set {_roll} to random number between 0 and 100
    
    set {_wCommon} to pet_getTierWeight({_tier}, "common")
    set {_wUncommon} to pet_getTierWeight({_tier}, "uncommon")
    set {_wRare} to pet_getTierWeight({_tier}, "rare")
    set {_wEpic} to pet_getTierWeight({_tier}, "epic")
    
    set {_threshold} to 0
    
    # Common
    add {_wCommon} to {_threshold}
    if {_roll} < {_threshold}:
        return "common"
    
    # Uncommon
    add {_wUncommon} to {_threshold}
    if {_roll} < {_threshold}:
        return "uncommon"
    
    # Rare
    add {_wRare} to {_threshold}
    if {_roll} < {_threshold}:
        return "rare"
    
    # Epic
    add {_wEpic} to {_threshold}
    if {_roll} < {_threshold}:
        return "epic"
    
    # Legendary
    return "legendary"


# Roll random pet type from tier
function pet_rollType(tier: text) :: text:
    set {_types::*} to {-pet::tier::%{_tier}%::types::*}
    set {_count} to size of {_types::*}
    
    if {_count} = 0:
        return "cow"
    
    set {_index} to random integer between 1 and {_count}
    return {_types::%{_index}%}


# ============================================================
# DEBUG COMMANDS
# ============================================================

command /testegg <text> [<number=1>]:
    permission: op
    trigger:
        set {_tier} to arg-1
        set {_amount} to arg-2
        
        if {-pet::tier::%{_tier}%::cost} is not set:
            send "&cInvalid tier: %{_tier}%"
            send "&7Available: normal, ultra, divine"
            stop
        
        if {_amount} < 1:
            set {_amount} to 1
        if {_amount} > 5:
            set {_amount} to 5
        
        send "&aOpening %{_amount}% %{_tier}% eggs (FREE - debug mode)"
        set {_loc} to location of targeted block
        if {_loc} is not set:
            set {_loc} to player's location
        pet_playOpeningSequence(player, {_tier}, {_amount}, {_loc})

command /testroll <text> [<number=100>]:
    permission: op
    trigger:
        set {_tier} to arg-1
        set {_rolls} to arg-2
        
        if {-pet::tier::%{_tier}%::cost} is not set:
            send "&cInvalid tier: %{_tier}%"
            stop
        
        set {_common} to 0
        set {_uncommon} to 0
        set {_rare} to 0
        set {_epic} to 0
        set {_legendary} to 0
        
        loop {_rolls} times:
            set {_rarity} to pet_rollRarity({_tier})
            if {_rarity} = "common":
                add 1 to {_common}
            else if {_rarity} = "uncommon":
                add 1 to {_uncommon}
            else if {_rarity} = "rare":
                add 1 to {_rare}
            else if {_rarity} = "epic":
                add 1 to {_epic}
            else if {_rarity} = "legendary":
                add 1 to {_legendary}
        
        send ""
        send "&6&lâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        send "&e&lğŸ² ROLL TEST: %{_tier}% (%{_rolls}% rolls)"
        send "&6&lâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        send "&7Common: &f%{_common}% &8(%round({_common} / {_rolls} * 100)%%%)"
        send "&aUncommon: &f%{_uncommon}% &8(%round({_uncommon} / {_rolls} * 100)%%%)"
        send "&9Rare: &f%{_rare}% &8(%round({_rare} / {_rolls} * 100)%%%)"
        send "&dEpic: &f%{_epic}% &8(%round({_epic} / {_rolls} * 100)%%%)"
        send "&6Legendary: &f%{_legendary}% &8(%round({_legendary} / {_rolls} * 100)%%%)"
        send "&6&lâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
