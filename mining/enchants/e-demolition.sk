# ============================================================
# DEMOLITION ARCHETYPE ENCHANTS
# ============================================================

# ============================================================
# STABILITY ENCHANT (Cooldown Reduction)
# ============================================================

function stability_getCooldownMultiplier(p: player) :: number:
    set {_id} to enchant_getIdByString("Stability")
    
    if enchant_checkIfEquipped({_p}, {_id}) = false:
        return 1.0
    
    set {_level} to enchant_getPlayerLevelByString({_p}, "Stability")
    
    if {_level} < 1:
        return 1.0
    
    # 0.4% reduction per level, max 20% at level 50
    set {_reduction} to {_level} * 0.004
    if {_reduction} > 0.2:
        set {_reduction} to 0.2
    
    set {_multiplier} to 1.0 - {_reduction}
    
    # Floor at 50% (0.5 multiplier)
    if {_multiplier} < 0.5:
        set {_multiplier} to 0.5
    
    return {_multiplier}


function stability_getReducedCooldown(p: player, baseCooldown: number) :: number:
    set {_multiplier} to stability_getCooldownMultiplier({_p})
    set {_reduced} to {_baseCooldown} * {_multiplier}
    
    # Floor at 50% of base
    set {_minimum} to {_baseCooldown} * 0.5
    if {_reduced} < {_minimum}:
        set {_reduced} to {_minimum}
    
    return {_reduced}


# ============================================================
# EXPLOSIVE ENCHANT
# ============================================================

function enchant_procExplosive(p: player, loc: location) :: boolean:
    set {_id} to enchant_getIdByString("Explosive")
    
    if enchant_checkIfEquipped({_p}, {_id}) = false:
        return false
    
    set {_level} to enchant_getPlayerLevelByString({_p}, "Explosive")
    
    if {_level} < 1:
        return false
    
    # Individual cooldown (15 seconds base)
    if {-explosive::%{_p}'s uuid%::cooldown} is set:
        return false
    
    # 0.4% per level, max 20% at level 50
    set {_baseChance} to {_level} * 0.4
    
    if enchant_rollChance({_p}, {_baseChance}) = false:
        return false
    
    # Set cooldown with Stability reduction
    set {-explosive::%{_p}'s uuid%::cooldown} to true
    set {_cooldown} to stability_getReducedCooldown({_p}, 15)
    explosive_clearCooldown({_p}, {_cooldown})
    
    # Radius scales with level: 1-24 = radius 1, 25-50 = radius 2
    set {_radius} to 1 + floor({_level} / 25)
    if {_radius} > 2:
        set {_radius} to 2
    
    explosive_detonate({_p}, {_loc}, {_radius})
    return true


function explosive_clearCooldown(p: player, cooldown: number):
    wait ("%{_cooldown}% seconds" parsed as timespan)
    delete {-explosive::%{_p}'s uuid%::cooldown}


function explosive_detonate(p: player, loc: location, radius: integer):
    set {_startX} to floor(x-coord of {_loc})
    set {_startY} to floor(y-coord of {_loc})
    set {_startZ} to floor(z-coord of {_loc})
    set {_world} to world of {_loc}
    
    set {_centerLoc} to location({_startX} + 0.5, {_startY} + 0.5, {_startZ} + 0.5, {_world})
    
    # Play explosion effect
    play sound "entity.generic.explode" with volume 0.7 and pitch 1.2 to {_p}
    play sound "entity.firework_rocket.blast" with volume 0.5 and pitch 0.8 to {_p}
    
    # Explosion particles at center
    draw 5 of poof at {_centerLoc} for {_p}
    draw 15 of smoke at {_centerLoc} with offset vector(0.5, 0.5, 0.5) for {_p}
    draw 10 of flame at {_centerLoc} with offset vector(0.4, 0.4, 0.4) for {_p}
    
    # Crack nearby blocks - same Y level only
    loop integers from (-1 * {_radius}) to {_radius}:
        set {_dx} to loop-value
        loop integers from (-1 * {_radius}) to {_radius}:
            set {_dz} to loop-value-2
            
            # Skip center
            if {_dx} = 0:
                if {_dz} = 0:
                    continue
            
            set {_checkLoc} to location({_startX} + {_dx}, {_startY}, {_startZ} + {_dz}, {_world})
            set {_checkType} to type of block at {_checkLoc}
            
            # Skip bedrock (respawning blocks)
            if {_checkType} is bedrock:
                continue
            
            if mining_isMineable({_checkType}) = true:
                if mining_isLocked({_p}, {_checkLoc}) = false:
                    explosive_crackBlock({_p}, {_checkLoc})
                    
                    # Small particle at cracked block
                    set {_bx} to floor(x-coord of {_checkLoc}) + 0.5
                    set {_by} to floor(y-coord of {_checkLoc}) + 0.5
                    set {_bz} to floor(z-coord of {_checkLoc}) + 0.5
                    set {_blockCenter} to location({_bx}, {_by}, {_bz}, {_world})
                    draw 3 of smoke at {_blockCenter} for {_p}


function explosive_crackBlock(p: player, loc: location):
    set {_currentProgress} to mining_getProgress({_p}, {_loc})
    set {_currentStage} to mining_getVisualStageFromProgress({_currentProgress})
    
    set {_stagesToAdd} to random integer between 2 and 4
    set {_progressToAdd} to {_stagesToAdd} / 10
    
    set {_newProgress} to {_currentProgress} + {_progressToAdd}
    
    # Cap at 80% (stage 8)
    if {_newProgress} > 0.8:
        set {_newProgress} to 0.8
    
    if mining_hasSession({_p}, {_loc}) = false:
        mining_createSession({_p}, {_loc})
    
    mining_setProgress({_p}, {_loc}, {_newProgress})
    
    set {_newStage} to mining_getVisualStageFromProgress({_newProgress})
    set {_id} to {-miningData::%{_p}'s uuid%::damageID::%{_loc}%}
    make {_p} see damage of block at {_loc} as {_newStage} / 10 from {_id}
    set {-miningData::%{_p}'s uuid%::lastStage::%{_loc}%} to {_newStage}


# ============================================================
# SHOCKWAVE ENCHANT
# ============================================================

function enchant_procShockwave(p: player, loc: location) :: boolean:
    set {_id} to enchant_getIdByString("Shockwave")
    
    if enchant_checkIfEquipped({_p}, {_id}) = false:
        return false
    
    set {_level} to enchant_getPlayerLevelByString({_p}, "Shockwave")
    
    if {_level} < 1:
        return false
    
    # Individual cooldown (18 seconds base)
    if {-shockwave::%{_p}'s uuid%::cooldown} is set:
        return false
    
    # 0.3% per level, max 15% at level 50
    set {_baseChance} to {_level} * 0.3
    
    if enchant_rollChance({_p}, {_baseChance}) = false:
        return false
    
    # Set cooldown with Stability reduction
    set {-shockwave::%{_p}'s uuid%::cooldown} to true
    set {_cooldown} to stability_getReducedCooldown({_p}, 18)
    shockwave_clearCooldown({_p}, {_cooldown})
    
    shockwave_pulse({_p}, {_loc})
    return true


function shockwave_clearCooldown(p: player, cooldown: number):
    wait ("%{_cooldown}% seconds" parsed as timespan)
    delete {-shockwave::%{_p}'s uuid%::cooldown}


function shockwave_pulse(p: player, loc: location):
    set {_startX} to floor(x-coord of {_loc})
    set {_startY} to floor(y-coord of {_loc})
    set {_startZ} to floor(z-coord of {_loc})
    set {_world} to world of {_loc}
    
    # Center position - Y+1 so it's ABOVE the block, visible
    set {_centerX} to {_startX} + 0.5
    set {_centerY} to {_startY} + 1.0
    set {_centerZ} to {_startZ} + 0.5
    set {_centerLoc} to location({_centerX}, {_centerY}, {_centerZ}, {_world})
    
    # ===== PULSE 1 - CYAN - radius 1 =====
    # Center burst to signal pulse start
    draw 15 of end rod at {_centerLoc} with offset vector(0.1, 0.1, 0.1) for {_p}
    play sound "block.beacon.activate" with volume 0.4 and pitch 2.0 to {_p}
    wait 3 ticks
    
    # Expand ring
    shockwave_expandRing({_p}, {_centerX}, {_centerY}, {_centerZ}, {_world}, 1.0, 1, {_loc})
    play sound "block.amethyst_block.chime" with volume 0.4 and pitch 1.0 to {_p}
    
    wait 15 ticks
    
    # ===== PULSE 2 - ORANGE/GOLD - radius 1.5 =====
    draw 15 of end rod at {_centerLoc} with offset vector(0.1, 0.1, 0.1) for {_p}
    play sound "block.beacon.activate" with volume 0.4 and pitch 1.7 to {_p}
    wait 3 ticks
    
    shockwave_expandRing({_p}, {_centerX}, {_centerY}, {_centerZ}, {_world}, 1.5, 2, {_loc})
    play sound "block.amethyst_block.chime" with volume 0.4 and pitch 1.3 to {_p}
    
    wait 15 ticks
    
    # ===== PULSE 3 - MAGENTA/PINK - radius 2 =====
    draw 15 of end rod at {_centerLoc} with offset vector(0.1, 0.1, 0.1) for {_p}
    play sound "block.beacon.activate" with volume 0.4 and pitch 1.4 to {_p}
    wait 3 ticks
    
    shockwave_expandRing({_p}, {_centerX}, {_centerY}, {_centerZ}, {_world}, 2.0, 3, {_loc})
    play sound "block.amethyst_block.chime" with volume 0.4 and pitch 1.6 to {_p}


function shockwave_expandRing(p: player, cx: number, cy: number, cz: number, world: world, maxRadius: number, pulse: integer, blockLoc: location):
    # 8 frames per ring expansion
    set {_frames} to 8
    set {_radiusStep} to {_maxRadius} / {_frames}
    
    set {_radius} to 0.1
    loop {_frames} times:
        set {_frame} to loop-number
        
        add {_radiusStep} to {_radius}
        
        # Draw ring
        shockwave_ring({_p}, {_cx}, {_cy}, {_cz}, {_world}, {_radius}, {_pulse}, {_maxRadius})
        
        wait 1 tick
    
    # Crack blocks after ring expands
    if {_maxRadius} >= 1:
        shockwave_crackAtRadius({_p}, {_blockLoc}, 1)
    if {_maxRadius} >= 1.5:
        shockwave_crackAtRadius({_p}, {_blockLoc}, 2)


function shockwave_ring(p: player, cx: number, cy: number, cz: number, world: world, radius: number, pulse: integer, maxRadius: number):
    # 40 points for a smooth circle
    set {_points} to 40
    
    # Particle size based on how expanded the ring is
    set {_progress} to {_radius} / {_maxRadius}
    set {_size} to 1.6 - ({_progress} * 0.6)
    if {_size} < 0.8:
        set {_size} to 0.8
    
    loop {_points} times:
        set {_i} to loop-number - 1
        set {_angle} to {_i} * 9
        
        # Calculate point on circle
        set {_x} to {_cx} + ({_radius} * cos({_angle}))
        set {_z} to {_cz} + ({_radius} * sin({_angle}))
        
        set {_loc} to location({_x}, {_cy}, {_z}, {_world})
        
        # Very different colors per pulse
        if {_pulse} = 1:
            # Bright Cyan
            draw 1 of dust using dustOption(rgb(0, 255, 255), {_size}) at {_loc} for {_p}
            if mod({_i}, 4) = 0:
                draw 1 of dust using dustOption(rgb(200, 255, 255), {_size} * 0.5) at {_loc} for {_p}
        else if {_pulse} = 2:
            # Orange / Gold
            draw 1 of dust using dustOption(rgb(255, 180, 0), {_size}) at {_loc} for {_p}
            if mod({_i}, 4) = 0:
                draw 1 of dust using dustOption(rgb(255, 255, 100), {_size} * 0.5) at {_loc} for {_p}
        else:
            # Magenta / Pink
            draw 1 of dust using dustOption(rgb(255, 50, 200), {_size}) at {_loc} for {_p}
            if mod({_i}, 4) = 0:
                draw 1 of dust using dustOption(rgb(255, 150, 255), {_size} * 0.5) at {_loc} for {_p}


function shockwave_crackAtRadius(p: player, center: location, radius: integer):
    set {_startX} to floor(x-coord of {_center})
    set {_startY} to floor(y-coord of {_center})
    set {_startZ} to floor(z-coord of {_center})
    set {_world} to world of {_center}
    
    # Only same Y level
    loop integers from ({_radius} * -1) to {_radius}:
        set {_dx} to loop-value
        loop integers from ({_radius} * -1) to {_radius}:
            set {_dz} to loop-value-2
            
            # Skip center
            if {_dx} = 0:
                if {_dz} = 0:
                    continue
            
            # Check if at this radius (ring, not filled circle)
            set {_dist} to sqrt(({_dx} * {_dx}) + ({_dz} * {_dz}))
            
            if {_dist} <= {_radius}:
                if {_dist} > ({_radius} - 1):
                    set {_checkLoc} to location({_startX} + {_dx}, {_startY}, {_startZ} + {_dz}, {_world})
                    set {_checkType} to type of block at {_checkLoc}
                    
                    # Skip bedrock (respawning blocks)
                    if {_checkType} is bedrock:
                        continue
                    
                    if mining_isMineable({_checkType}) = true:
                        if mining_isLocked({_p}, {_checkLoc}) = false:
                            shockwave_crackBlock({_p}, {_checkLoc})


function shockwave_crackBlock(p: player, loc: location):
    set {_currentProgress} to mining_getProgress({_p}, {_loc})
    set {_currentStage} to mining_getVisualStageFromProgress({_currentProgress})
    
    set {_stagesToAdd} to random integer between 2 and 3
    set {_progressToAdd} to {_stagesToAdd} / 10
    
    set {_newProgress} to {_currentProgress} + {_progressToAdd}
    
    # Cap at 80% (stage 8)
    if {_newProgress} > 0.8:
        set {_newProgress} to 0.8
    
    if mining_hasSession({_p}, {_loc}) = false:
        mining_createSession({_p}, {_loc})
    
    mining_setProgress({_p}, {_loc}, {_newProgress})
    
    set {_newStage} to mining_getVisualStageFromProgress({_newProgress})
    set {_id} to {-miningData::%{_p}'s uuid%::damageID::%{_loc}%}
    make {_p} see damage of block at {_loc} as {_newStage} / 10 from {_id}
    set {-miningData::%{_p}'s uuid%::lastStage::%{_loc}%} to {_newStage}
    
    # Small impact particle
    set {_bx} to floor(x-coord of {_loc}) + 0.5
    set {_by} to floor(y-coord of {_loc}) + 0.5
    set {_bz} to floor(z-coord of {_loc}) + 0.5
    set {_blockCenter} to location({_bx}, {_by}, {_bz}, world of {_loc})
    draw 2 of dust using dustOption(rgb(0, 200, 200), 0.8) at {_blockCenter} for {_p}


# ============================================================
# LIGHTNING ENCHANT
# ============================================================

function enchant_procLightning(p: player, loc: location) :: boolean:
    set {_id} to enchant_getIdByString("Lightning")
    
    if enchant_checkIfEquipped({_p}, {_id}) = false:
        return false
    
    set {_level} to enchant_getPlayerLevelByString({_p}, "Lightning")
    
    if {_level} < 1:
        return false
    
    # Individual cooldown (12 seconds base)
    if {-lightning::%{_p}'s uuid%::cooldown} is set:
        return false
    
    # 0.3% per level, max 15% at level 50
    set {_baseChance} to {_level} * 0.3
    
    if enchant_rollChance({_p}, {_baseChance}) = false:
        return false
    
    # Set cooldown with Stability reduction
    set {-lightning::%{_p}'s uuid%::cooldown} to true
    set {_cooldown} to stability_getReducedCooldown({_p}, 12)
    lightning_clearCooldown({_p}, {_cooldown})
    
    # Radius scales with level: 1-24 = radius 1, 25-50 = radius 2
    set {_radius} to 1 + floor({_level} / 25)
    if {_radius} > 2:
        set {_radius} to 2
    
    lightning_strike({_p}, {_loc}, {_radius})
    return true


function lightning_clearCooldown(p: player, cooldown: number):
    wait ("%{_cooldown}% seconds" parsed as timespan)
    delete {-lightning::%{_p}'s uuid%::cooldown}


function lightning_strike(p: player, loc: location, radius: integer):
    set {_startX} to floor(x-coord of {_loc})
    set {_startY} to floor(y-coord of {_loc})
    set {_startZ} to floor(z-coord of {_loc})
    set {_world} to world of {_loc}
    
    # Dramatic buildup sound
    play sound "entity.elder_guardian.curse" with volume 0.3 and pitch 2.0 to {_p}
    
    # Find valid targets - same Y level only
    set {_validCount} to 0
    
    loop integers from ({_radius} * -1) to {_radius}:
        set {_dx} to loop-value
        loop integers from ({_radius} * -1) to {_radius}:
            set {_dz} to loop-value-2
            
            # Skip center
            if {_dx} = 0:
                if {_dz} = 0:
                    continue
            
            set {_checkLoc} to location({_startX} + {_dx}, {_startY}, {_startZ} + {_dz}, {_world})
            set {_checkType} to type of block at {_checkLoc}
            
            # Skip bedrock (respawning blocks)
            if {_checkType} is bedrock:
                continue
            
            if mining_isMineable({_checkType}) = true:
                if mining_isLocked({_p}, {_checkLoc}) = false:
                    add 1 to {_validCount}
                    set {_validLoc::%{_validCount}%} to {_checkLoc}
    
    if {_validCount} = 0:
        stop
    
    # Strike 2 random blocks
    set {_strikes} to 2
    if {_validCount} < 2:
        set {_strikes} to {_validCount}
    
    set {_struckCount} to 0
    loop {_strikes} times:
        # Pick random valid block that hasn't been struck
        set {_attempts} to 0
        while {_attempts} < 10:
            add 1 to {_attempts}
            set {_pick} to random integer between 1 and {_validCount}
            if {_validLoc::%{_pick}%} is set:
                set {_targetLoc} to {_validLoc::%{_pick}%}
                delete {_validLoc::%{_pick}%}
                
                add 1 to {_struckCount}
                
                # Delay between strikes
                if {_struckCount} > 1:
                    wait 5 ticks
                
                # Strike this block
                lightning_strikeBlock({_p}, {_targetLoc})
                stop loop


function lightning_strikeBlock(p: player, loc: location):
    # Get block center for particles
    set {_bx} to floor(x-coord of {_loc}) + 0.5
    set {_by} to floor(y-coord of {_loc}) + 0.5
    set {_bz} to floor(z-coord of {_loc}) + 0.5
    set {_center} to location({_bx}, {_by}, {_bz}, world of {_loc})
    
    # Pre-strike charge sound
    play sound "block.respawn_anchor.charge" with volume 0.4 and pitch 2.0 to {_p}
    
    wait 2 ticks
    
    # Spawn fake lightning
    spawn fake lightning at {_loc} for {_p}
    
    # Thunder and impact sounds - layered for satisfaction
    play sound "entity.lightning_bolt.thunder" with volume 0.6 and pitch 1.0 to {_p}
    play sound "entity.lightning_bolt.impact" with volume 0.5 and pitch 1.2 to {_p}
    play sound "entity.firework_rocket.blast" with volume 0.3 and pitch 0.5 to {_p}
    play sound "block.anvil.land" with volume 0.2 and pitch 1.5 to {_p}
    
    # Electric particles - bright yellow/white burst
    draw 20 of dust using dustOption(rgb(255, 255, 100), 1.5) at {_center} with offset vector(0.4, 0.4, 0.4) for {_p}
    draw 15 of dust using dustOption(rgb(255, 255, 255), 1.0) at {_center} with offset vector(0.3, 0.3, 0.3) for {_p}
    draw 10 of dust using dustOption(rgb(200, 200, 255), 0.8) at {_center} with offset vector(0.25, 0.25, 0.25) for {_p}
    draw 8 of crit at {_center} with offset vector(0.3, 0.3, 0.3) for {_p}
    draw 5 of end rod at {_center} with offset vector(0.2, 0.2, 0.2) for {_p}
    
    # Crack the block
    lightning_crackBlock({_p}, {_loc})


function lightning_crackBlock(p: player, loc: location):
    set {_currentProgress} to mining_getProgress({_p}, {_loc})
    
    set {_stagesToAdd} to random integer between 2 and 4
    set {_progressToAdd} to {_stagesToAdd} / 10
    
    set {_newProgress} to {_currentProgress} + {_progressToAdd}
    
    # Cap at 80% (stage 8)
    if {_newProgress} > 0.8:
        set {_newProgress} to 0.8
    
    if mining_hasSession({_p}, {_loc}) = false:
        mining_createSession({_p}, {_loc})
    
    mining_setProgress({_p}, {_loc}, {_newProgress})
    
    set {_newStage} to mining_getVisualStageFromProgress({_newProgress})
    set {_id} to {-miningData::%{_p}'s uuid%::damageID::%{_loc}%}
    make {_p} see damage of block at {_loc} as {_newStage} / 10 from {_id}
    set {-miningData::%{_p}'s uuid%::lastStage::%{_loc}%} to {_newStage}


# ============================================================
# EARTHQUAKE ENCHANT
# ============================================================

function enchant_procEarthquake(p: player, loc: location) :: boolean:
    set {_id} to enchant_getIdByString("Earthquake")
    
    if enchant_checkIfEquipped({_p}, {_id}) = false:
        return false
    
    set {_level} to enchant_getPlayerLevelByString({_p}, "Earthquake")
    
    if {_level} < 1:
        return false
    
    # Individual cooldown (20 seconds base)
    if {-earthquake::%{_p}'s uuid%::cooldown} is set:
        return false
    
    # 0.2% per level, max 10% at level 50
    set {_baseChance} to {_level} * 0.2
    
    if enchant_rollChance({_p}, {_baseChance}) = false:
        return false
    
    # Set cooldown with Stability reduction
    set {-earthquake::%{_p}'s uuid%::cooldown} to true
    set {_cooldown} to stability_getReducedCooldown({_p}, 20)
    earthquake_clearCooldown({_p}, {_cooldown})
    
    # Radius scales with level: 1-24 = radius 2, 25-50 = radius 3
    set {_radius} to 2 + floor({_level} / 25)
    if {_radius} > 3:
        set {_radius} to 3
    
    earthquake_trigger({_p}, {_loc}, {_radius})
    return true


function earthquake_clearCooldown(p: player, cooldown: number):
    wait ("%{_cooldown}% seconds" parsed as timespan)
    delete {-earthquake::%{_p}'s uuid%::cooldown}


function earthquake_trigger(p: player, loc: location, radius: integer):
    set {_startX} to floor(x-coord of {_loc})
    set {_startY} to floor(y-coord of {_loc})
    set {_startZ} to floor(z-coord of {_loc})
    set {_world} to world of {_loc}
    
    set {_centerLoc} to location({_startX} + 0.5, {_startY} + 0.5, {_startZ} + 0.5, {_world})
    
    # ===== PHASE 1: Initial rumble =====
    play sound "entity.warden.emerge" with volume 0.5 and pitch 0.4 to {_p}
    play sound "entity.ender_dragon.growl" with volume 0.3 and pitch 0.5 to {_p}
    
    # Spawn 5 shaking dirt block displays in a pattern
    set {_displayCount} to 5
    
    # Center block
    set {_displayLoc::1} to location({_startX} + 0.5, {_startY} + 1.0, {_startZ} + 0.5, {_world})
    # Corner blocks
    set {_displayLoc::2} to location({_startX} + 0.0, {_startY} + 0.8, {_startZ} + 0.0, {_world})
    set {_displayLoc::3} to location({_startX} + 1.0, {_startY} + 0.9, {_startZ} + 0.0, {_world})
    set {_displayLoc::4} to location({_startX} + 0.0, {_startY} + 0.85, {_startZ} + 1.0, {_world})
    set {_displayLoc::5} to location({_startX} + 1.0, {_startY} + 0.95, {_startZ} + 1.0, {_world})
    
    # Spawn all displays
    loop {_displayCount} times:
        set {_i} to loop-number
        set {_displayId::%{_i}%} to random integer between 100000 and 999999
        
        spawn fake block display at {_displayLoc::%{_i}%} for {_p} with id {_displayId::%{_i}%}
        
        # Vary sizes for more natural look
        if {_i} = 1:
            set {_scale} to 0.6
        else:
            set {_scale} to 0.3 + (random number between 0 and 0.2)
        
        set {_m} to new metadata packet with id {_displayId::%{_i}%}:
            display block: dirt
            display scale: vector({_scale}, {_scale}, {_scale})
            display billboard: center
            display brightness block: 15
            display teleportduration: 1
            display transformation: 1
            display interpolation: 0
        send packet {_m} to {_p}
    
    wait 2 ticks
    
    # ===== PHASE 2: Violent shaking =====
    play sound "entity.warden.roar" with volume 0.4 and pitch 0.3 to {_p}
    
    loop 12 times:
        set {_frame} to loop-number
        
        # Shake all displays with increasing intensity
        set {_intensity} to 0.1 + ({_frame} * 0.02)
        
        loop {_displayCount} times:
            set {_i} to loop-number-2
            set {_baseX} to x-coord of {_displayLoc::%{_i}%}
            set {_baseY} to y-coord of {_displayLoc::%{_i}%}
            set {_baseZ} to z-coord of {_displayLoc::%{_i}%}
            
            set {_offsetX} to (random number between (0 - {_intensity}) and {_intensity})
            set {_offsetZ} to (random number between (0 - {_intensity}) and {_intensity})
            set {_offsetY} to (random number between (0 - {_intensity} / 2) and {_intensity})
            
            set {_shakeLoc} to location({_baseX} + {_offsetX}, {_baseY} + {_offsetY}, {_baseZ} + {_offsetZ}, {_world})
            send teleport packet with id {_displayId::%{_i}%} with location {_shakeLoc} to {_p}
        
        # Dust particles burst outward during shake
        if mod({_frame}, 3) = 0:
            draw 8 of dust using dustOption(rgb(139, 90, 43), 1.5) at {_centerLoc} with offset vector(0.5, 0.3, 0.5) for {_p}
            play sound "block.gravel.step" with volume 0.3 and pitch (0.5 + (random number between 0 and 0.3)) to {_p}
        
        wait 2 ticks
    
    # ===== PHASE 3: Ground crack wave =====
    # Big impact sound
    play sound "entity.warden.sonic_boom" with volume 0.3 and pitch 0.5 to {_p}
    play sound "block.anvil.land" with volume 0.4 and pitch 0.6 to {_p}
    play sound "entity.generic.explode" with volume 0.3 and pitch 0.7 to {_p}
    
    # Dust explosion
    draw 25 of dust using dustOption(rgb(139, 90, 43), 2.0) at {_centerLoc} with offset vector(1.0, 0.5, 1.0) for {_p}
    draw 15 of dust using dustOption(rgb(100, 70, 30), 1.5) at {_centerLoc} with offset vector(0.8, 0.4, 0.8) for {_p}
    
    # Collect all blocks to crack
    set {_crackCount} to 0
    
    loop integers from ({_radius} * -1) to {_radius}:
        set {_dx} to loop-value
        loop integers from ({_radius} * -1) to {_radius}:
            set {_dz} to loop-value-2
            
            # Skip center
            if {_dx} = 0:
                if {_dz} = 0:
                    continue
            
            # Check circular radius
            set {_dist} to sqrt(({_dx} * {_dx}) + ({_dz} * {_dz}))
            if {_dist} <= {_radius}:
                set {_checkLoc} to location({_startX} + {_dx}, {_startY}, {_startZ} + {_dz}, {_world})
                set {_checkType} to type of block at {_checkLoc}
                
                # Skip bedrock (respawning blocks)
                if {_checkType} is bedrock:
                    continue
                
                if mining_isMineable({_checkType}) = true:
                    if mining_isLocked({_p}, {_checkLoc}) = false:
                        add 1 to {_crackCount}
                        set {_crackLoc::%{_crackCount}%} to {_checkLoc}
    
    # Inner wave (radius 1) - with sound
    play sound "block.basalt.break" with volume 0.5 and pitch 0.6 to {_p}
    loop {_crackCount} times:
        set {_blockLoc} to {_crackLoc::%loop-number%}
        set {_bx} to x-coord of {_blockLoc} - {_startX}
        set {_bz} to z-coord of {_blockLoc} - {_startZ}
        set {_blockDist} to sqrt(({_bx} * {_bx}) + ({_bz} * {_bz}))
        
        if {_blockDist} <= 1.5:
            earthquake_crackBlock({_p}, {_blockLoc})
    
    wait 3 ticks
    
    # Outer wave (radius 2+) - with sound
    play sound "block.basalt.break" with volume 0.4 and pitch 0.7 to {_p}
    play sound "block.deepslate.break" with volume 0.4 and pitch 0.5 to {_p}
    
    loop {_crackCount} times:
        set {_blockLoc} to {_crackLoc::%loop-number%}
        set {_bx} to x-coord of {_blockLoc} - {_startX}
        set {_bz} to z-coord of {_blockLoc} - {_startZ}
        set {_blockDist} to sqrt(({_bx} * {_bx}) + ({_bz} * {_bz}))
        
        if {_blockDist} > 1.5:
            earthquake_crackBlock({_p}, {_blockLoc})
    
    # ===== PHASE 4: Settle and cleanup =====
    wait 2 ticks
    
    # Make displays fall and shrink
    loop {_displayCount} times:
        set {_i} to loop-number
        set {_fallLoc} to {_displayLoc::%{_i}%} ~ vector(0, -0.3, 0)
        send teleport packet with id {_displayId::%{_i}%} with location {_fallLoc} to {_p}
        
        set {_m} to new metadata packet with id {_displayId::%{_i}%}:
            display scale: vector(0.01, 0.01, 0.01)
            display transformation: 4
            display interpolation: 0
        send packet {_m} to {_p}
    
    # Final dust settling
    draw 20 of dust using dustOption(rgb(139, 90, 43), 1.0) at {_centerLoc} with offset vector({_radius} * 0.6, 0.2, {_radius} * 0.6) for {_p}
    draw 10 of campfire cosy smoke at {_centerLoc} with offset vector({_radius} * 0.3, 0.1, {_radius} * 0.3) for {_p}
    
    # Satisfying end sound
    play sound "block.rooted_dirt.break" with volume 0.5 and pitch 0.7 to {_p}
    play sound "block.moss.break" with volume 0.3 and pitch 0.6 to {_p}
    
    wait 4 ticks
    
    # Remove all displays
    loop {_displayCount} times:
        set {_i} to loop-number
        remove fake entity with id {_displayId::%{_i}%} for {_p}


function earthquake_crackBlock(p: player, loc: location):
    set {_currentProgress} to mining_getProgress({_p}, {_loc})
    
    # Fixed 3 stages
    set {_progressToAdd} to 0.3
    
    set {_newProgress} to {_currentProgress} + {_progressToAdd}
    
    # Cap at 80% (stage 8)
    if {_newProgress} > 0.8:
        set {_newProgress} to 0.8
    
    if mining_hasSession({_p}, {_loc}) = false:
        mining_createSession({_p}, {_loc})
    
    mining_setProgress({_p}, {_loc}, {_newProgress})
    
    set {_newStage} to mining_getVisualStageFromProgress({_newProgress})
    set {_id} to {-miningData::%{_p}'s uuid%::damageID::%{_loc}%}
    make {_p} see damage of block at {_loc} as {_newStage} / 10 from {_id}
    set {-miningData::%{_p}'s uuid%::lastStage::%{_loc}%} to {_newStage}
    
    # Dust particle at cracked block
    set {_bx} to floor(x-coord of {_loc}) + 0.5
    set {_by} to floor(y-coord of {_loc}) + 0.5
    set {_bz} to floor(z-coord of {_loc}) + 0.5
    set {_blockCenter} to location({_bx}, {_by}, {_bz}, world of {_loc})
    draw 3 of dust using dustOption(rgb(139, 90, 43), 1.0) at {_blockCenter} for {_p}
    
    # Small crack sound
    play sound "block.stone.hit" with volume 0.2 and pitch 0.8 at {_loc} for {_p}


