# ============================================================
# ARCANE ARCHETYPE ENCHANTS
# ============================================================

# ============================================================
# TORNADO ENCHANT
# ============================================================

function enchant_procTornado(p: player, loc: location) :: boolean:
    set {_id} to enchant_getIdByString("Tornado")
    
    if enchant_checkIfEquipped({_p}, {_id}) = false:
        return false
    
    set {_level} to enchant_getPlayerLevelByString({_p}, "Tornado")
    
    if {_level} < 1:
        return false
    
    set {_baseChance} to {_level} * 0.005
    
    if enchant_rollChance({_p}, {_baseChance}) = false:
        return false
    
    tornado_spawn({_p}, {_loc})
    return true


function tornado_spawn(p: player, loc: location):
    set {_startX} to floor(x-coord of {_loc})
    set {_startY} to floor(y-coord of {_loc})
    set {_startZ} to floor(z-coord of {_loc})
    set {_world} to world of {_loc}
    
    set {_offX::1} to 1
    set {_offZ::1} to 0
    set {_offX::2} to 1
    set {_offZ::2} to 1
    set {_offX::3} to 0
    set {_offZ::3} to 1
    set {_offX::4} to -1
    set {_offZ::4} to 1
    set {_offX::5} to -1
    set {_offZ::5} to 0
    set {_offX::6} to -1
    set {_offZ::6} to -1
    set {_offX::7} to 0
    set {_offZ::7} to -1
    set {_offX::8} to 1
    set {_offZ::8} to -1
    set {_offX::9} to 2
    set {_offZ::9} to 0
    set {_offX::10} to 2
    set {_offZ::10} to 1
    set {_offX::11} to 2
    set {_offZ::11} to 2
    set {_offX::12} to 1
    set {_offZ::12} to 2
    set {_offX::13} to 0
    set {_offZ::13} to 2
    set {_offX::14} to -1
    set {_offZ::14} to 2
    set {_offX::15} to -2
    set {_offZ::15} to 2
    set {_offX::16} to -2
    set {_offZ::16} to 1
    
    set {_totalBlocks} to 16
    
    set {_baseId} to random integer between 100000 and 9999999
    set {_entityCount} to 0
    
    set {_ringHeight::1} to 0.1
    set {_ringRadius::1} to 0.15
    set {_ringCount::1} to 4
    set {_ringHeight::2} to 0.4
    set {_ringRadius::2} to 0.25
    set {_ringCount::2} to 5
    set {_ringHeight::3} to 0.7
    set {_ringRadius::3} to 0.35
    set {_ringCount::3} to 6
    set {_ringHeight::4} to 1.0
    set {_ringRadius::4} to 0.45
    set {_ringCount::4} to 6
    set {_ringHeight::5} to 1.4
    set {_ringRadius::5} to 0.55
    set {_ringCount::5} to 7
    set {_ringHeight::6} to 1.8
    set {_ringRadius::6} to 0.65
    set {_ringCount::6} to 8
    
    set {_numRings} to 6
    
    set {_centerX} to {_startX} + 0.5
    set {_centerZ} to {_startZ} + 0.5
    set {_spawnLoc} to location({_centerX}, {_startY} + 1, {_centerZ}, {_world})
    
    loop {_numRings} times:
        set {_ring} to loop-number
        set {_count} to {_ringCount::%{_ring}%}
        
        loop {_count} times:
            add 1 to {_entityCount}
            set {_eid::%{_entityCount}%} to {_baseId} + {_entityCount}
            set {_eRing::%{_entityCount}%} to {_ring}
            set {_eIndex::%{_entityCount}%} to loop-number-2
            set {_eAngleOffset::%{_entityCount}%} to ((loop-number-2) - 1) * (360 / {_count})
            
            spawn fake item display at {_spawnLoc} for {_p} with id {_eid::%{_entityCount}%}
            
            if {_ring} <= 2:
                set {_item} to gray concrete
            else if {_ring} <= 4:
                set {_item} to light gray concrete
            else:
                set {_item} to white concrete
            
            set {_baseScale} to 0.2 + (random number between 0 and 0.15)
            
            set {_m} to new metadata packet with id {_eid::%{_entityCount}%}:
                display item: {_item}
                display scale: vector(0.01, 0.01, 0.01)
                display billboard: center
                display brightness block: 15
                display teleportduration: 1
            send packet {_m} to {_p}
            
            set {_eScale::%{_entityCount}%} to {_baseScale}
    
    set {_totalEntities} to {_entityCount}
    
    play sound "entity.wither.shoot" with volume 0.3 and pitch 1.8 to {_p}
    
    wait 1 tick
    
    loop {_totalEntities} times:
        set {_e} to loop-number
        set {_s} to {_eScale::%{_e}%}
        
        set {_m} to new metadata packet with id {_eid::%{_e}%}:
            display scale: vector({_s}, {_s}, {_s})
            display transformation: 3
            display interpolation: 0
        send packet {_m} to {_p}
    
    wait 2 ticks
    
    set {_spinAngle} to 0
    
    loop {_totalBlocks} times:
        set {_blockIndex} to loop-number
        set {_targetX} to {_startX} + {_offX::%{_blockIndex}%} + 0.5
        set {_targetZ} to {_startZ} + {_offZ::%{_blockIndex}%} + 0.5
        
        set {_blockLoc} to location({_startX} + {_offX::%{_blockIndex}%}, {_startY}, {_startZ} + {_offZ::%{_blockIndex}%}, {_world})
        set {_blockType} to type of block at {_blockLoc}
        
        loop 3 times:
            add 30 to {_spinAngle}
            
            set {_progress} to loop-number-2 / 3
            set {_curX} to {_centerX} + (({_targetX} - {_centerX}) * {_progress})
            set {_curZ} to {_centerZ} + (({_targetZ} - {_centerZ}) * {_progress})
            
            loop {_totalEntities} times:
                set {_e} to loop-number-3
                set {_ring} to {_eRing::%{_e}%}
                set {_angleOffset} to {_eAngleOffset::%{_e}%}
                
                set {_height} to {_startY} + 1 + {_ringHeight::%{_ring}%}
                set {_radius} to {_ringRadius::%{_ring}%}
                
                set {_ringSpinMod} to 1 + ({_ring} * 0.1)
                set {_angle} to ({_spinAngle} * {_ringSpinMod}) + {_angleOffset}
                
                set {_px} to {_curX} + ({_radius} * cos({_angle}))
                set {_pz} to {_curZ} + ({_radius} * sin({_angle}))
                
                set {_entityLoc} to location({_px}, {_height}, {_pz}, {_world})
                send teleport packet with id {_eid::%{_e}%} with location {_entityLoc} to {_p}
            
            wait 1 tick
        
        set {_centerX} to {_targetX}
        set {_centerZ} to {_targetZ}
        
        if mod({_blockIndex}, 4) = 0:
            play sound "entity.phantom.flap" with volume 0.2 and pitch 1.5 to {_p}
        
        # Skip bedrock (respawning blocks)
        if {_blockType} is bedrock:
            continue
        
        if mining_isMineable({_blockType}) = true:
            if mining_isLocked({_p}, {_blockLoc}) = false:
                tornado_crackBlock({_p}, {_blockLoc})
    
    loop 8 times:
        set {_frame} to loop-number
        add 45 to {_spinAngle}
        
        set {_shrink} to 1 - ({_frame} * 0.12)
        set {_rise} to {_frame} * 0.2
        
        loop {_totalEntities} times:
            set {_e} to loop-number-2
            set {_ring} to {_eRing::%{_e}%}
            set {_angleOffset} to {_eAngleOffset::%{_e}%}
            set {_s} to {_eScale::%{_e}%}
            
            set {_height} to {_startY} + 1 + {_ringHeight::%{_ring}%} + {_rise}
            set {_radius} to {_ringRadius::%{_ring}%} * {_shrink}
            
            set {_ringSpinMod} to 1 + ({_ring} * 0.15)
            set {_angle} to ({_spinAngle} * {_ringSpinMod}) + {_angleOffset}
            
            set {_px} to {_centerX} + ({_radius} * cos({_angle}))
            set {_pz} to {_centerZ} + ({_radius} * sin({_angle}))
            
            set {_entityLoc} to location({_px}, {_height}, {_pz}, {_world})
            send teleport packet with id {_eid::%{_e}%} with location {_entityLoc} to {_p}
            
            set {_newScale} to {_s} * {_shrink}
            set {_m} to new metadata packet with id {_eid::%{_e}%}:
                display scale: vector({_newScale}, {_newScale}, {_newScale})
                display transformation: 2
                display interpolation: 0
            send packet {_m} to {_p}
        
        wait 1 tick
    
    play sound "block.powder_snow.break" with volume 0.4 and pitch 1.2 to {_p}
    
    wait 2 ticks
    
    loop {_totalEntities} times:
        set {_e} to loop-number
        remove fake entity with id {_eid::%{_e}%} for {_p}


function tornado_crackBlock(p: player, loc: location):
    set {_currentProgress} to mining_getProgress({_p}, {_loc})
    set {_currentStage} to mining_getVisualStageFromProgress({_currentProgress})
    
    set {_stagesToAdd} to random integer between 2 and 4
    set {_progressToAdd} to {_stagesToAdd} / 10
    
    set {_newProgress} to {_currentProgress} + {_progressToAdd}
    
    if {_newProgress} > 0.8:
        set {_newProgress} to 0.8
    
    if mining_hasSession({_p}, {_loc}) = false:
        mining_createSession({_p}, {_loc})
    
    mining_setProgress({_p}, {_loc}, {_newProgress})
    
    set {_newStage} to mining_getVisualStageFromProgress({_newProgress})
    set {_id} to {-miningData::%{_p}'s uuid%::damageID::%{_loc}%}
    make {_p} see damage of block at {_loc} as {_newStage} / 10 from {_id}
    set {-miningData::%{_p}'s uuid%::lastStage::%{_loc}%} to {_newStage}
    
    play sound "block.stone.hit" with volume 0.15 and pitch 0.9 at {_loc} for {_p}


# ============================================================
# AMPLIFY ENCHANT
# ============================================================

function enchant_procAmplify(p: player, loc: location):
    set {_id} to enchant_getIdByString("Amplify")
    
    if enchant_checkIfEquipped({_p}, {_id}) = false:
        stop
    
    set {_level} to enchant_getPlayerLevelByString({_p}, "Amplify")
    
    if {_level} < 1:
        stop
    
    set {_baseChance} to {_level} * 0.05
    
    if enchant_rollChance({_p}, {_baseChance}) = false:
        stop
    
    set {_startX} to floor(x-coord of {_loc})
    set {_startY} to floor(y-coord of {_loc})
    set {_startZ} to floor(z-coord of {_loc})
    set {_world} to world of {_loc}
    
    set {_validCount} to 0
    
    # Same Y level only
    loop integers from -1 to 1:
        set {_dx} to loop-value
        loop integers from -1 to 1:
            set {_dz} to loop-value-2
            
            if {_dx} = 0:
                if {_dz} = 0:
                    continue
            
            set {_checkLoc} to location({_startX} + {_dx}, {_startY}, {_startZ} + {_dz}, {_world})
            set {_checkType} to type of block at {_checkLoc}
            
            # Skip bedrock (respawning blocks)
            if {_checkType} is bedrock:
                continue
            
            if mining_isMineable({_checkType}) = true:
                if mining_isLocked({_p}, {_checkLoc}) = false:
                    set {_bx} to floor(x-coord of {_checkLoc})
                    set {_by} to floor(y-coord of {_checkLoc})
                    set {_bz} to floor(z-coord of {_checkLoc})
                    set {_locKey} to "%{_bx}%_%{_by}%_%{_bz}%"
                    if {-amplified::%{_p}'s uuid%::%{_locKey}%} is not set:
                        add 1 to {_validCount}
                        set {_validLoc::%{_validCount}%} to {_checkLoc}
                        set {_validType::%{_validCount}%} to {_checkType}
    
    if {_validCount} = 0:
        stop
    
    set {_toAmplify} to random integer between 1 and 3
    if {_toAmplify} > {_validCount}:
        set {_toAmplify} to {_validCount}
    
    set {_amplified} to 0
    loop {_validCount} times:
        if {_amplified} >= {_toAmplify}:
            stop
        
        set {_remaining} to {_validCount} - (loop-number - 1)
        set {_needed} to {_toAmplify} - {_amplified}
        set {_pickChance} to {_needed} / {_remaining}
        
        if random number between 0 and 1 <= {_pickChance}:
            set {_targetLoc} to {_validLoc::%loop-number%}
            set {_targetType} to {_validType::%loop-number%}
            amplify_markBlock({_p}, {_targetLoc}, {_targetType})
            add 1 to {_amplified}
    
    play sound "block.respawn_anchor.charge" with volume 0.5 and pitch 1.5 to {_p}


function amplify_markBlock(p: player, loc: location, blockType: item):
    set {_id} to random integer between 100000 and 9999999
    
    set {_bx} to floor(x-coord of {_loc})
    set {_by} to floor(y-coord of {_loc})
    set {_bz} to floor(z-coord of {_loc})
    set {_world} to world of {_loc}
    
    set {_spawnLoc} to location({_bx} + 0.5, {_by} + 0.5, {_bz} + 0.5, {_world})
    
    set {_locKey} to "%{_bx}%_%{_by}%_%{_bz}%"
    set {-amplified::%{_p}'s uuid%::%{_locKey}%} to {_id}
    
    spawn fake item display at {_spawnLoc} for {_p} with id {_id}
    
    # Use same block type but glowing purple
    set {_m} to new metadata packet with id {_id}:
        display item: {_blockType}
        display scale: vector(1.01, 1.01, 1.01)
        display brightness block: 15
        glowing: true
        display glow: rgb(200, 50, 200)
    send packet {_m} to {_p}
    
    amplify_scheduleExpire({_p}, {_loc}, {_id})


function amplify_scheduleExpire(p: player, loc: location, entityId: integer):
    wait 10 seconds
    
    set {_bx} to floor(x-coord of {_loc})
    set {_by} to floor(y-coord of {_loc})
    set {_bz} to floor(z-coord of {_loc})
    set {_locKey} to "%{_bx}%_%{_by}%_%{_bz}%"
    
    if {-amplified::%{_p}'s uuid%::%{_locKey}%} = {_entityId}:
        remove fake entity with id {_entityId} for {_p}
        delete {-amplified::%{_p}'s uuid%::%{_locKey}%}


function amplify_isAmplified(p: player, loc: location) :: boolean:
    set {_bx} to floor(x-coord of {_loc})
    set {_by} to floor(y-coord of {_loc})
    set {_bz} to floor(z-coord of {_loc})
    set {_locKey} to "%{_bx}%_%{_by}%_%{_bz}%"
    
    if {-amplified::%{_p}'s uuid%::%{_locKey}%} is set:
        return true
    return false


function amplify_clearBlock(p: player, loc: location):
    set {_bx} to floor(x-coord of {_loc})
    set {_by} to floor(y-coord of {_loc})
    set {_bz} to floor(z-coord of {_loc})
    set {_locKey} to "%{_bx}%_%{_by}%_%{_bz}%"
    
    if {-amplified::%{_p}'s uuid%::%{_locKey}%} is set:
        set {_id} to {-amplified::%{_p}'s uuid%::%{_locKey}%}
        remove fake entity with id {_id} for {_p}
        delete {-amplified::%{_p}'s uuid%::%{_locKey}%}


function amplify_clearAll(p: player):
    loop {-amplified::%{_p}'s uuid%::*}:
        set {_id} to loop-value
        remove fake entity with id {_id} for {_p}
    delete {-amplified::%{_p}'s uuid%::*}


function amplify_showText(p: player, loc: location):
    set {_textId} to random integer between 100000 and 9999999
    
    set {_bx} to floor(x-coord of {_loc}) + 0.5
    set {_by} to floor(y-coord of {_loc}) + 1.5
    set {_bz} to floor(z-coord of {_loc}) + 0.5
    set {_pos} to location({_bx}, {_by}, {_bz}, world of {_loc})
    
    spawn fake text display at {_pos} for {_p} with id {_textId}
    
    set {_m} to new metadata packet with id {_textId}:
        display text: "&d&lAMPLIFIED! &5&l2x"
        display billboard: center
        display brightness block: 15
        display shadow: true
        display defaultbackground: false
        display scale: vector(0.01, 0.01, 0.01)
        display teleportduration: 2
    send packet {_m} to {_p}
    
    wait 1 tick
    
    set {_m} to new metadata packet with id {_textId}:
        display scale: vector(1.2, 1.2, 1.2)
        display transformation: 3
        display interpolation: 0
    send packet {_m} to {_p}
    
    wait 2 ticks
    
    set {_m} to new metadata packet with id {_textId}:
        display scale: vector(1, 1, 1)
        display transformation: 3
        display interpolation: 0
    send packet {_m} to {_p}
    
    set {_endPos} to location({_bx}, {_by} + 0.5, {_bz}, world of {_loc})
    send teleport packet with id {_textId} with location {_endPos} to {_p}
    
    wait 15 ticks
    
    set {_m} to new metadata packet with id {_textId}:
        display scale: vector(0.01, 0.01, 0.01)
        display transformation: 3
        display interpolation: 0
    send packet {_m} to {_p}
    
    wait 4 ticks
    
    remove fake entity with id {_textId} for {_p}


# ============================================================
# OVERCHARGE ENCHANT (Arcane)
# ============================================================

function overcharge_onBlockBreak(p: player):
    set {_id} to enchant_getIdByString("Overcharge")
    
    if enchant_checkIfEquipped({_p}, {_id}) = false:
        stop
    
    set {_level} to enchant_getPlayerLevelByString({_p}, "Overcharge")
    
    if {_level} < 1:
        stop
    
    # Already overcharged, don't count
    if {-overcharge::%{_p}'s uuid%::ready} is set:
        stop
    
    # Blocks needed: 15 at level 1, 8 at level 50
    set {_blocksNeeded} to 15 - floor({_level} / 7)
    if {_blocksNeeded} < 8:
        set {_blocksNeeded} to 8
    
    # Increment counter
    if {-overcharge::%{_p}'s uuid%::counter} is not set:
        set {-overcharge::%{_p}'s uuid%::counter} to 0
    
    add 1 to {-overcharge::%{_p}'s uuid%::counter}
    
    # Check if ready
    if {-overcharge::%{_p}'s uuid%::counter} >= {_blocksNeeded}:
        set {-overcharge::%{_p}'s uuid%::ready} to true
        set {-overcharge::%{_p}'s uuid%::counter} to 0
        overcharge_notifyReady({_p})


function overcharge_notifyReady(p: player):
    # Sound notification
    play sound "block.beacon.activate" with volume 0.5 and pitch 1.5 to {_p}
    play sound "block.respawn_anchor.charge" with volume 0.4 and pitch 1.8 to {_p}
    
    # Actionbar message
    send action bar "&d&l⚡ OVERCHARGED &d&l⚡" to {_p}


function overcharge_getBonusDamage(p: player) :: number:
    set {_id} to enchant_getIdByString("Overcharge")
    
    if enchant_checkIfEquipped({_p}, {_id}) = false:
        return 0
    
    if {-overcharge::%{_p}'s uuid%::ready} is not set:
        return 0
    
    set {_level} to enchant_getPlayerLevelByString({_p}, "Overcharge")
    
    # Bonus: 1% per level, max 50% at level 50
    set {_bonus} to {_level} * 0.01
    if {_bonus} > 0.5:
        set {_bonus} to 0.5
    
    return {_bonus}


function overcharge_consume(p: player, loc: location):
    if {-overcharge::%{_p}'s uuid%::ready} is not set:
        stop
    
    # Clear ready state
    delete {-overcharge::%{_p}'s uuid%::ready}
    
    # Play consume effects
    overcharge_playEffect({_p}, {_loc})


function overcharge_playEffect(p: player, loc: location):
    set {_bx} to floor(x-coord of {_loc}) + 0.5
    set {_by} to floor(y-coord of {_loc}) + 0.5
    set {_bz} to floor(z-coord of {_loc}) + 0.5
    set {_center} to location({_bx}, {_by}, {_bz}, world of {_loc})
    
    # Big purple/magenta burst
    draw 25 of dust using dustOption(rgb(200, 50, 255), 1.8) at {_center} with offset vector(0.5, 0.5, 0.5) for {_p}
    draw 15 of dust using dustOption(rgb(255, 100, 255), 1.4) at {_center} with offset vector(0.4, 0.4, 0.4) for {_p}
    draw 10 of dust using dustOption(rgb(255, 200, 255), 1.0) at {_center} with offset vector(0.3, 0.3, 0.3) for {_p}
    draw 8 of end rod at {_center} with offset vector(0.3, 0.3, 0.3) for {_p}
    draw 5 of enchanted hit at {_center} with offset vector(0.2, 0.2, 0.2) for {_p}
    
    # Satisfying sounds
    play sound "entity.player.attack.crit" with volume 0.6 and pitch 0.8 to {_p}
    play sound "block.amethyst_block.break" with volume 0.5 and pitch 1.2 to {_p}
    play sound "entity.illusioner.cast_spell" with volume 0.4 and pitch 1.0 to {_p}
    
    # Spawn text display
    set {_textId} to random integer between 100000 and 9999999
    set {_textLoc} to location({_bx}, {_by} + 1.2, {_bz}, world of {_loc})
    
    spawn fake text display at {_textLoc} for {_p} with id {_textId}
    
    set {_m} to new metadata packet with id {_textId}:
        display text: "&d&l⚡ OVERCHARGE ⚡"
        display scale: vector(0.01, 0.01, 0.01)
        display billboard: center
        display brightness block: 15
        display teleportduration: 2
        display transformation: 3
        display interpolation: 0
        display background alpha: 0
    send packet {_m} to {_p}
    
    wait 1 tick
    
    # Pop in
    set {_m} to new metadata packet with id {_textId}:
        display scale: vector(1.3, 1.3, 1.3)
        display transformation: 3
        display interpolation: 0
    send packet {_m} to {_p}
    
    wait 3 ticks
    
    # Settle
    set {_m} to new metadata packet with id {_textId}:
        display scale: vector(1, 1, 1)
        display transformation: 3
        display interpolation: 0
    send packet {_m} to {_p}
    
    # Float up
    set {_endLoc} to location({_bx}, {_by} + 1.8, {_bz}, world of {_loc})
    send teleport packet with id {_textId} with location {_endLoc} to {_p}
    
    wait 15 ticks
    
    # Fade out
    set {_m} to new metadata packet with id {_textId}:
        display scale: vector(0.01, 0.01, 0.01)
        display transformation: 4
        display interpolation: 0
    send packet {_m} to {_p}
    
    wait 4 ticks
    
    remove fake entity with id {_textId} for {_p}


function overcharge_isReady(p: player) :: boolean:
    if {-overcharge::%{_p}'s uuid%::ready} is set:
        return true
    return false


function overcharge_clearAll(p: player):
    delete {-overcharge::%{_p}'s uuid%::*}


