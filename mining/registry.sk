# ============================================================
# BLOCK REGISTRY SYSTEM
# ============================================================

function mining_registerBlock(block: item, hardness: number, drops: items, price: number):
    set {mining.registry::%{_block}%::hardness} to {_hardness}
    set {mining.registry::%{_block}%::drops::*} to {_drops::*}
    set {mining.registry::%{_block}%::price} to {_price}
    add {_block} to {mining.registry::blocks::*}


function mining_registerBlocks():
    delete {mining.registry::*}
    
    # ============================================================
    # BLOCK TYPE HARDNESS REFERENCE:
    # Wool             = 1.0 (Tier 1) - $40
    # Terracotta       = 1.5 (Tier 2) - $80
    # Concrete         = 2.0 (Tier 3) - $120
    # Glazed Terracotta = 2.5 (Tier 4) - $160
    # ============================================================
    
    # ============ WHITE ============
    mining_registerBlock(white wool, 1.0, (1 of white wool), 40)
    mining_registerBlock(white terracotta, 1.5, (1 of white terracotta), 80)
    mining_registerBlock(white concrete, 2.0, (1 of white concrete), 120)
    mining_registerBlock(white glazed terracotta, 2.5, (1 of white glazed terracotta), 160)
    
    # ============ ORANGE ============
    mining_registerBlock(orange wool, 1.0, (1 of orange wool), 40)
    mining_registerBlock(orange terracotta, 1.5, (1 of orange terracotta), 80)
    mining_registerBlock(orange concrete, 2.0, (1 of orange concrete), 120)
    mining_registerBlock(orange glazed terracotta, 2.5, (1 of orange glazed terracotta), 160)
    
    # ============ MAGENTA ============
    mining_registerBlock(magenta wool, 1.0, (1 of magenta wool), 40)
    mining_registerBlock(magenta terracotta, 1.5, (1 of magenta terracotta), 80)
    mining_registerBlock(magenta concrete, 2.0, (1 of magenta concrete), 120)
    mining_registerBlock(magenta glazed terracotta, 2.5, (1 of magenta glazed terracotta), 160)
    
    # ============ LIGHT BLUE ============
    mining_registerBlock(light blue wool, 1.0, (1 of light blue wool), 40)
    mining_registerBlock(light blue terracotta, 1.5, (1 of light blue terracotta), 80)
    mining_registerBlock(light blue concrete, 2.0, (1 of light blue concrete), 120)
    mining_registerBlock(light blue glazed terracotta, 2.5, (1 of light blue glazed terracotta), 160)
    
    # ============ YELLOW ============
    mining_registerBlock(yellow wool, 1.0, (1 of yellow wool), 40)
    mining_registerBlock(yellow terracotta, 1.5, (1 of yellow terracotta), 80)
    mining_registerBlock(yellow concrete, 2.0, (1 of yellow concrete), 120)
    mining_registerBlock(yellow glazed terracotta, 2.5, (1 of yellow glazed terracotta), 160)
    
    # ============ LIME ============
    mining_registerBlock(lime wool, 1.0, (1 of lime wool), 40)
    mining_registerBlock(lime terracotta, 1.5, (1 of lime terracotta), 80)
    mining_registerBlock(lime concrete, 2.0, (1 of lime concrete), 120)
    mining_registerBlock(lime glazed terracotta, 2.5, (1 of lime glazed terracotta), 160)
    
    # ============ PINK ============
    mining_registerBlock(pink wool, 1.0, (1 of pink wool), 40)
    mining_registerBlock(pink terracotta, 1.5, (1 of pink terracotta), 80)
    mining_registerBlock(pink concrete, 2.0, (1 of pink concrete), 120)
    mining_registerBlock(pink glazed terracotta, 2.5, (1 of pink glazed terracotta), 160)
    
    # ============ GRAY ============
    mining_registerBlock(gray wool, 1.0, (1 of gray wool), 40)
    mining_registerBlock(gray terracotta, 1.5, (1 of gray terracotta), 80)
    mining_registerBlock(gray concrete, 2.0, (1 of gray concrete), 120)
    mining_registerBlock(gray glazed terracotta, 2.5, (1 of gray glazed terracotta), 160)
    
    # ============ LIGHT GRAY ============
    mining_registerBlock(light gray wool, 1.0, (1 of light gray wool), 40)
    mining_registerBlock(light gray terracotta, 1.5, (1 of light gray terracotta), 80)
    mining_registerBlock(light gray concrete, 2.0, (1 of light gray concrete), 120)
    mining_registerBlock(light gray glazed terracotta, 2.5, (1 of light gray glazed terracotta), 160)
    
    # ============ CYAN ============
    mining_registerBlock(cyan wool, 1.0, (1 of cyan wool), 40)
    mining_registerBlock(cyan terracotta, 1.5, (1 of cyan terracotta), 80)
    mining_registerBlock(cyan concrete, 2.0, (1 of cyan concrete), 120)
    mining_registerBlock(cyan glazed terracotta, 2.5, (1 of cyan glazed terracotta), 160)
    
    # ============ PURPLE ============
    mining_registerBlock(purple wool, 1.0, (1 of purple wool), 40)
    mining_registerBlock(purple terracotta, 1.5, (1 of purple terracotta), 80)
    mining_registerBlock(purple concrete, 2.0, (1 of purple concrete), 120)
    mining_registerBlock(purple glazed terracotta, 2.5, (1 of purple glazed terracotta), 160)
    
    # ============ BLUE ============
    mining_registerBlock(blue wool, 1.0, (1 of blue wool), 40)
    mining_registerBlock(blue terracotta, 1.5, (1 of blue terracotta), 80)
    mining_registerBlock(blue concrete, 2.0, (1 of blue concrete), 120)
    mining_registerBlock(blue glazed terracotta, 2.5, (1 of blue glazed terracotta), 160)
    
    # ============ BROWN ============
    mining_registerBlock(brown wool, 1.0, (1 of brown wool), 40)
    mining_registerBlock(brown terracotta, 1.5, (1 of brown terracotta), 80)
    mining_registerBlock(brown concrete, 2.0, (1 of brown concrete), 120)
    mining_registerBlock(brown glazed terracotta, 2.5, (1 of brown glazed terracotta), 160)
    
    # ============ GREEN ============
    mining_registerBlock(green wool, 1.0, (1 of green wool), 40)
    mining_registerBlock(green terracotta, 1.5, (1 of green terracotta), 80)
    mining_registerBlock(green concrete, 2.0, (1 of green concrete), 120)
    mining_registerBlock(green glazed terracotta, 2.5, (1 of green glazed terracotta), 160)
    
    # ============ RED ============
    mining_registerBlock(red wool, 1.0, (1 of red wool), 40)
    mining_registerBlock(red terracotta, 1.5, (1 of red terracotta), 80)
    mining_registerBlock(red concrete, 2.0, (1 of red concrete), 120)
    mining_registerBlock(red glazed terracotta, 2.5, (1 of red glazed terracotta), 160)
    
    # ============ BLACK ============
    mining_registerBlock(black wool, 1.0, (1 of black wool), 40)
    mining_registerBlock(black terracotta, 1.5, (1 of black terracotta), 80)
    mining_registerBlock(black concrete, 2.0, (1 of black concrete), 120)
    mining_registerBlock(black glazed terracotta, 2.5, (1 of black glazed terracotta), 160)
    
    # Build sellable items list for quick lookup
    delete {mining.sellable::*}
    loop {mining.registry::blocks::*}:
        set {_drops::*} to {mining.registry::%loop-value%::drops::*}
        set {_price} to {mining.registry::%loop-value%::price}
        loop {_drops::*}:
            set {_type} to type of loop-value-2
            set {mining.sellable::%{_type}%} to {_price}
    
    # broadcast "&a[Mining] Registered %size of {mining.registry::blocks::*}% blocks."

# ============================================================
# REGISTRY GEM FUNCTIONS - UPDATE
# ============================================================
#
# REPLACE your existing gem functions in registry.sk with these.
# These are used by the animation system (packetPouchGems, prospecting_showText)
#
# New gem names based on prestige tiers:
#   Tier 1: Jade (Prestige 0)
#   Tier 2: Topaz (Prestige 1-2)
#   Tier 3: Sapphire (Prestige 3-4)
#   Tier 4: Ruby (Prestige 5-6)
#   Tier 5: Amethyst (Prestige 7+)
#
# ============================================================

function mining_registerGems():
    # No longer needs hardness-based registration
    # Tiers are now prestige-based (handled in gems-core.sk)
    stop


# ============================================================
# ANIMATION FUNCTIONS (used by mining-animations.sk)
# ============================================================

function gem_getName(tier: integer) :: string:
    if {_tier} = 1:
        return "Jade"
    if {_tier} = 2:
        return "Topaz"
    if {_tier} = 3:
        return "Sapphire"
    if {_tier} = 4:
        return "Ruby"
    if {_tier} = 5:
        return "Amethyst"
    return "Gem"


function gem_getTierColor(tier: integer) :: string:
    if {_tier} = 1:
        return "&a"
    if {_tier} = 2:
        return "&6"
    if {_tier} = 3:
        return "&b"
    if {_tier} = 4:
        return "&c"
    if {_tier} = 5:
        return "&d"
    return "&7"


function gem_getItem(tier: integer) :: item type:
    # Return dyes matching gem colors for animations
    if {_tier} = 1:
        return lime dye
    if {_tier} = 2:
        return orange dye
    if {_tier} = 3:
        return light blue dye
    if {_tier} = 4:
        return red dye
    if {_tier} = 5:
        return purple dye
    return lime dye


function gem_getGlowColor(tier: integer) :: color:
    if {_tier} = 1:
        return rgb(85, 255, 85)      # Jade - green
    if {_tier} = 2:
        return rgb(255, 170, 0)      # Topaz - gold
    if {_tier} = 3:
        return rgb(85, 255, 255)     # Sapphire - aqua
    if {_tier} = 4:
        return rgb(255, 85, 85)      # Ruby - red
    if {_tier} = 5:
        return rgb(255, 85, 255)     # Amethyst - purple
    return rgb(255, 255, 255)


# ============================================================
# LEGACY FUNCTION - NO LONGER USED
# ============================================================
# Kept for any old code that might reference it
# New system uses gem_getPlayerTier() from gems-core.sk

function gem_getTierFromHardness(hardness: number) :: integer:
    # This is deprecated - tier is now based on player prestige
    # Returns tier 1 as fallback
    return 1
# ============================================================
# SELL FUNCTIONS
# ============================================================

function mining_getPrice(item: item) :: number:
    set {_type} to type of {_item}
    return {mining.sellable::%{_type}%} ? 0


function mining_canSell(item: item) :: boolean:
    set {_type} to type of {_item}
    if {mining.sellable::%{_type}%} is set:
        return true
    return false


function mining_sellItem(p: player, item: item) :: number:
    if mining_canSell({_item}) = false:
        return 0
    
    set {_price} to mining_getPrice({_item})
    set {_amount} to item amount of {_item}
    set {_total} to {_price} * {_amount}
    # Apply money multiplier
    set {_total} to {_total} * multiplier_getMoney({_p})

    add {_total} to {data::balance::%{_p}'s uuid%}
    
    return {_total}


function mining_sellAll(p: player) :: number:
    set {_totalEarned} to 0
    set {_itemsSold} to 0
    
    loop all items in {_p}'s inventory:
        if mining_canSell(loop-item) = true:
            set {_earned} to mining_sellItem({_p}, loop-item)
            add {_earned} to {_totalEarned}
            add item amount of loop-item to {_itemsSold}
            remove loop-item from {_p}'s inventory
    
    return {_totalEarned}


function mining_sellHand(p: player) :: number:
    set {_item} to {_p}'s tool
    
    if mining_canSell({_item}) = false:
        return 0
    
    set {_earned} to mining_sellItem({_p}, {_item})
    remove {_item} from {_p}'s inventory
    
    return {_earned}


# ============================================================
# SELL COMMANDS
# ============================================================

command /sell [<text>]:
    trigger:
        if arg-1 is not set:
            set {_earned} to mining_sellAll(player)
            if {_earned} = 0:
                send "&cYou don't have anything to sell!"
            else:
                play sound "entity.experience_orb.pickup" with volume 0.8 and pitch 1.2 to player
                send "&aSold all items for &2$%formatNum({_earned})%&a!"
                tutorial_onSell(player)
        
        else if arg-1 is "all":
            set {_earned} to mining_sellAll(player)
            if {_earned} = 0:
                send "&cYou don't have anything to sell!"
            else:
                play sound "entity.experience_orb.pickup" with volume 0.8 and pitch 1.2 to player
                send "&aSold all items for &2$%formatNum({_earned})%&a!"
                tutorial_onSell(player)
        
        else if arg-1 is "hand":
            set {_earned} to mining_sellHand(player)
            if {_earned} = 0:
                send "&cYou can't sell this item!"
            else:
                play sound "entity.experience_orb.pickup" with volume 0.8 and pitch 1.2 to player
                send "&aSold for &2$%formatNum({_earned})%&a!"
                tutorial_onSell(player)
        
        else:
            send "&eUsage: &f/sell &7or &f/sell all &7or &f/sell hand"


command /price:
    trigger:
        set {_item} to player's tool
        if mining_canSell({_item}) = false:
            send "&cThis item can't be sold."
        else:
            set {_price} to mining_getPrice({_item})
            send "&ePrice: &2$%formatNum({_price})% &7each"


function mining_isMineable(block: item) :: boolean:
    if {mining.registry::%{_block}%::hardness} is set:
        return true
    return false


function mining_isLocked(p: player, loc: location) :: boolean:
    set {_bx} to floor(x-coord of {_loc})
    set {_by} to floor(y-coord of {_loc})
    set {_bz} to floor(z-coord of {_loc})
    set {_lockKey} to "%{_bx}%_%{_by}%_%{_bz}%"
    if {-miningLocked::%{_p}'s uuid%::%{_lockKey}%} is set:
        return true
    return false


function mining_getHardness(block: item) :: number:
    return {mining.registry::%{_block}%::hardness} ? 1


function mining_getRandomDrop(block: item) :: item:
    set {_drops::*} to {mining.registry::%{_block}%::drops::*}
    if size of {_drops::*} = 0:
        return air
    return random element of {_drops::*}


function mining_getAllDrops(block: item) :: items:
    return {mining.registry::%{_block}%::drops::*}


function mining_giveDrops(p: player, block: item, fortuneLevel: integer = 0, multiplier: integer = 1):
    set {_drop} to mining_getRandomDrop({_block})

    if {_drop} is air:
        stop

    set {_amount} to item amount of {_drop}
    if {_fortuneLevel} > 0:
        set {_bonus} to random integer between 0 and {_fortuneLevel}
        add {_bonus} to {_amount}

    set {_amount} to {_amount} * {_multiplier}

    # Apply drops multiplier (from pets, accessories, archetype)
    set {_dropsMultiplier} to multiplier_getDrops({_p})
    set {_amount} to round({_amount} * {_dropsMultiplier})
    if {_amount} < 1:
        set {_amount} to 1

    # Check for Autosell enchant
    if enchant_hasAutosell({_p}) = true:
        set {_earned} to enchant_autosellDrop({_p}, {_drop}, {_amount})
        if {_earned} > 0:
            # Add to pending autosell earnings for batched display
            add {_earned} to {-autosell::%{_p}'s uuid%::pending}
            if {-autosell::%{_p}'s uuid%::scheduled} is not set:
                set {-autosell::%{_p}'s uuid%::scheduled} to true
                autosell_flushEarnings({_p})
            stop

    # Check if inventory is full
    if {_p} cannot hold 1 of type of {_drop}:
        # Show inventory full message (throttled)
        if {-invFull::%{_p}'s uuid%::cooldown} is not set:
            send "&cInventory full! Use /sell or enable Autosell enchant." to {_p}
            play sound "entity.villager.no" with volume 0.5 and pitch 1.2 to {_p}
            set {-invFull::%{_p}'s uuid%::cooldown} to true
            wait 3 seconds
            delete {-invFull::%{_p}'s uuid%::cooldown}
        stop

    set {_finalDrop} to {_amount} of type of {_drop}
    give {_finalDrop} to {_p}

    play sound "entity.item.pickup" with volume 0.5 and pitch 1.2 at {_p} for {_p}