# ============================================================
# SKILL TREE - CORE FUNCTIONS
# ============================================================
#
# Data Storage:
#   {data::skills::%uuid%::%nodeId%}    â†’ rank (0 = not purchased)
#   {data::skills::%uuid%::spent}       â†’ total points spent
#
# ============================================================

# ============================================================
# RANK GETTERS
# ============================================================

function skilltree_getNodeRank(p: player, nodeId: text) :: number:
    return {data::skills::%{_p}'s uuid%::%{_nodeId}%} ? 0

function skilltree_getTotalSpent(p: player) :: number:
    return {data::skills::%{_p}'s uuid%::spent} ? 0

function skilltree_isNodeMaxed(p: player, nodeId: text) :: boolean:
    set {_rank} to skilltree_getNodeRank({_p}, {_nodeId})
    set {_max} to skilltree_getNodeMaxRank({_nodeId})
    if {_rank} >= {_max}:
        return true
    return false

function skilltree_isNodeUnlocked(p: player, nodeId: text) :: boolean:
    if skilltree_getNodeRank({_p}, {_nodeId}) > 0:
        return true
    return false


# ============================================================
# DEPENDENCY CHECK
# ============================================================

function skilltree_canPurchase(p: player, nodeId: text) :: boolean:
    # Already maxed
    if skilltree_isNodeMaxed({_p}, {_nodeId}) is true:
        return false

    # Check dependency
    set {_req} to skilltree_getNodeRequires({_nodeId})
    if {_req} is not "":
        if skilltree_isNodeMaxed({_p}, {_req}) is false:
            return false

    # Check cost
    set {_rank} to skilltree_getNodeRank({_p}, {_nodeId})
    set {_nextRank} to {_rank} + 1
    set {_cost} to skilltree_getNodeRankCost({_nodeId}, {_nextRank})
    if economy_hasPrestigePoints({_p}, {_cost}) is false:
        return false

    return true


# ============================================================
# PURCHASE
# ============================================================

function skilltree_purchase(p: player, nodeId: text) :: boolean:
    if skilltree_canPurchase({_p}, {_nodeId}) is false:
        return false

    set {_uuid} to {_p}'s uuid
    set {_rank} to skilltree_getNodeRank({_p}, {_nodeId})
    set {_nextRank} to {_rank} + 1
    set {_cost} to skilltree_getNodeRankCost({_nodeId}, {_nextRank})

    # Deduct points
    economy_removePrestigePoints({_p}, {_cost})

    # Set rank
    set {data::skills::%{_uuid}%::%{_nodeId}%} to {_nextRank}

    # Track total spent
    add {_cost} to {data::skills::%{_uuid}%::spent}

    # Recalculate multipliers
    multiplier_recalculate({_p})

    return true


# ============================================================
# RESPEC
# ============================================================

function skilltree_respec(p: player) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_cost} to skilltree_getRespecCost()

    if economy_hasMoney({_p}, {_cost}) is false:
        return false

    # Calculate total points to refund
    set {_refund} to 0
    loop {-skilltree::allNodes::*}:
        set {_nodeId} to loop-value
        set {_rank} to skilltree_getNodeRank({_p}, {_nodeId})
        if {_rank} > 0:
            loop integers from 1 to {_rank}:
                add skilltree_getNodeRankCost({_nodeId}, loop-number) to {_refund}
            delete {data::skills::%{_uuid}%::%{_nodeId}%}

    # Deduct money
    economy_removeMoney({_p}, {_cost})

    # Refund prestige points
    economy_addPrestigePoints({_p}, {_refund})

    # Reset spent counter
    set {data::skills::%{_uuid}%::spent} to 0

    # Recalculate multipliers
    multiplier_recalculate({_p})

    return true


# ============================================================
# BONUS GETTERS (for multiplier integration)
# ============================================================

function skilltree_getTotalBonus(p: player, stat: text) :: number:
    set {_total} to 0
    loop {-skilltree::allNodes::*}:
        set {_nodeId} to loop-value
        set {_rank} to skilltree_getNodeRank({_p}, {_nodeId})
        if {_rank} > 0:
            # Primary stat
            set {_nodeStat} to skilltree_getNodeStat({_nodeId})
            if {_nodeStat} is {_stat}:
                add skilltree_getNodeBonus({_nodeId}) * {_rank} to {_total}
            # Secondary stat (dual-stat nodes)
            set {_stat2} to {-skilltree::node::%{_nodeId}%::bonusStat2}
            if {_stat2} is set:
                if {_stat2} is {_stat}:
                    set {_bonus2} to {-skilltree::node::%{_nodeId}%::bonus2} ? 0
                    add {_bonus2} * {_rank} to {_total}
    return {_total}


# ============================================================
# MECHANIC CHECKS (for proc systems)
# ============================================================

function skilltree_hasMechanic(p: player, mechanic: text) :: boolean:
    loop {-skilltree::allNodes::*}:
        set {_nodeId} to loop-value
        set {_mech} to skilltree_getNodeMechanic({_nodeId})
        if {_mech} is {_mechanic}:
            if skilltree_getNodeRank({_p}, {_nodeId}) > 0:
                return true
    return false
